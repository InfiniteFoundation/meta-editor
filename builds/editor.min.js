"use strict";

var wabi = 
{
	addTemplate: function(id, extend, props)
	{
		if(!id) {
			console.warn("(wabi.addTemplate) Invalid template id passed");
			return false;
		}

		if(typeof(extend) === "object") {
			props = extend;
			extend = null;
		}

		if(!props.type) {
			console.warn("(wabi.addTemplate) Invalid template type passed");
			return false;
		}		

		if(this.templates[id]) {
			console.warn("(wabi.addTemplate) There is already added template with such id: " + props.id);
			return false;
		}

		this.templates[id] = props;

		return true;
	},

	createTemplate: function(id)
	{
		var props = this.templates[id];
		if(!props) {
			console.warn("(wabi.createTemplate) Template not found: " + id);
			return null;
		}

		var template = wabi.createElement(props.type);
		template.flags |= template.Flag.REGION;

		for(var key in props) 
		{
			if(key === "type") { continue; }
			
			template[key] = props[key];
		}

		return template;
	},

	createData: function(data) {
		return new wabi.data(data || {});
	},	

	addFragment: function(id, extend, props)
	{
		if(!id) {
			console.warn("(wabi.addFragment) Invalid fragment id passed");
			return false;
		}	

		if(this.fragments[id]) {
			console.warn("(wabi.addFragment) There is already added fragment with such id: " + id);
			return false;
		}

		if(!props) {
			props = extend;
			extend = null;
		}

		this.fragments[id] = new this.Fragment(id, extend, props);

		return true;
	},

	getFragment: function(id) 
	{
		var fragment = this.fragments[id];
		if(!fragment) {
			console.warn("(wabi.getTemplate) Could not find fragment with id: " + id);
			return null;
		}

		if(fragment.extend) 
		{
			var props = this.extendFragment([], fragment.extend);
			props = this.appendProps(props, fragment.props);
			return props;
		}

		return fragment.props;
	},

	extendFragment: function(props, extend)
	{
		for(var n = 0; n < extend.length; n++)
		{
			var fragment = this.fragments[extend[n]];
			if(!fragment) {
				console.warn("(wabi.extendFragment) Could not find fragment with id: " + fragment.id);
				continue;
			}
			else 
			{
				if(fragment.extend) {
					props = this.extendFragment(props, fragment.extend);
				}

				props = this.appendProps(props, fragment.props);
			}
		}

		return props;
	},

	appendProps: function(props, fragmentProps)
	{
		if(fragmentProps instanceof Array) {
			props = props.concat(fragmentProps);
		}
		else {
			props.push(fragmentProps);
		}
		
		return props;
	},

	createElement: function(name, parent, params)
	{
		var element;
		var buffer = this.elementsCached[name];
		if(buffer && buffer.length > 0) 
		{
			element = buffer.pop();
			if(element) 
			{
				element.flags = element.flagsInitial;

				if(parent) {
					element.parent = parent;
				}
			}
		}
		else 
		{
			var cls = this.element[name];
			if(!cls) {			
				console.warn("(editor.createElement) No such element found: " + name);
				return null;
			}

			element = new this.element[name](parent, params);
		}

		element._setup();

		return element;
	},

	removeElement: function(element)
	{
		if(!element || !(element instanceof wabi.element.basic)) {
			return console.warn("(wabi.removeElement) Invalid element passed");
		}

		element._remove();

		var buffer = this.elementsCached[element._metadata.name];
		if(!buffer) {
			buffer = [ element ];
			this.elementsCached[element._metadata.name] = buffer;
		}
		else {
			buffer.push(element);
		}
	},

	on: function(name, func, owner)
	{
		if(!func) {
			console.warn("(wabi.on) Invalid callback function passed");
			return;
		}

		var buffer = this.listeners[name];
		if(!buffer) 
		{
			var eventName = "on" + name;
			if(window[eventName] === void(0)) { 
				console.warn("(wabi.on) No such global event available: " + name);
				return;
			}

			buffer = [ new this.Watcher(owner, func) ];
			this.listeners[name] = buffer;

			window[eventName] = function(domEvent) 
			{
				var event = new wabi.event(name, null, domEvent);
				for(var n = 0; n < buffer.length; n++) {
					var watcher = buffer[n];
					watcher.func.call(watcher.owner, event);
				}
			}
		}
		else 
		{
			buffer.push(new this.Watcher(owner, func));
		}
	},

	off: function(name, func, owner)
	{
		if(!func) {
			return console.warn("(wabi.on) Invalid callback function passed");
		}

		var buffer = this.listeners[name];
		if(!buffer) {
			return console.warn("(wabi.off) No listeners found for event: " + name);
		}

		var num = buffer.length;
		for(var n = 0; n < num; n++)
		{
			var listener = buffer[n];
			if(listener.func === func && listener.owner === owner)
			{
				buffer[n] = buffer[num - 1];
				buffer.pop();
				break;
			}
		}
	},

	element: function(name, extend, props) 
	{
		if(props === undefined) {
			props = extend;
			extend = null;
		}

		if(this.elementDefs[name]) {
			console.warn("(wabi.element) There is already defined element with such name: " + name);
			return;
		}

		var elementDef = new this.ElementDef(props, extend);
		this.elementDefs[name] = elementDef;

		if(name === "basic") {
			this.compileBasicElement(props, extend);
		}
		else {
			this.compileElement(name, props, extend);
		}
	},	

	// TODO: Re-do how properties are registered.
	genPrototype: function(name, extend, props)
	{
		if(extend) 
		{
			var extendedDef = this.elementDefs[extend];
			if(!extendedDef) {
				console.warn("(wabi.genPrototype) Extended class not found: " + extend);
				return;
			}

			var newProps = {};
			this.assignObj(newProps, extendedDef.props);
			this.assignObj(newProps, props);
			props = newProps;
		}		

		var states = {};
		var statesLinked = {};
		var elementsLinked = {};
		var elementsBinded = {};
		var elements = {};
		var events = [];
		var proto = {};
		var numElements = 0;
		var valueLinked = false;

		if(props.elements) 
		{
			var elementsProps = props.elements;
			for(var elementKey in elementsProps)
			{
				var elementSlotId = elementKey;
				var item = elementsProps[elementSlotId];
				var state = {};
				var watch = {};
				var params = {};

				var link = null;
				var type = null;
				var bind = null;

				if(!item) {}
				else if(typeof item === "string") {
					type = item;
				}
				else
				{
					if(item.type) { type = item.type; }
					if(item.link) { link = item.link; }
					if(item.bind) { bind = item.bind; }

					var watchKeyword = "watch_";
					var watchKeywordLength = watchKeyword.length;

					for(var key in item)
					{
						if(key === "type" || key === "link" || key === "bind") { continue; }

						if(key[0] === "$") {
							state[key.slice(1)] = item[key];
						}
						else if(key.indexOf(watchKeyword) > -1) {
							watch[key.slice(watchKeywordLength)] = item[key];
						}
						else {
							params[key] = item[key];
						}
					}
				}

				var newItem = { 
					type: type,
					link: link,
					slot: numElements++,
					state: state,
					watch: watch,
					params: params
				};

				if(link)
				{
					statesLinked[link] = elementKey;
					elementsLinked[elementKey] = link;
				}

				if(bind) {
					elementsBinded[elementKey] = bind;
				}

				elements[elementSlotId] = newItem;
			}

			delete props.elements;
		}

		// Defines states:
		var statesDefined = props.state;
		var statesInitial = statesDefined;
		if(statesDefined)
		{
			for(var key in statesDefined) {
				states[key] = statesDefined[key];
			}
		}

		// Define properties:
		for(var key in props)
		{
			var p = Object.getOwnPropertyDescriptor(props, key);
			if(p.get || p.set) {
				Object.defineProperty(proto, key, p);
				continue;
			}

			var variable = props[key];
			var variableType = typeof(variable);

			if(variableType === "function")
			{
				var buffer = key.split("_");
				if(buffer.length > 1 && buffer[0] !== "")
				{
					var stateName = buffer[1];

					if(buffer[0] !== "handle") 
					{
						if(states[stateName] === undefined) {
							states[stateName] = null;
						}
					}
					else {
						events.push(stateName);
					}
				}
			}

			proto[key] = variable;
		}

		var statesProto;

		if(name !== "basic")
		{
			var basicMetadata = this.element.basic.prototype._metadata;
			var basicStates = basicMetadata.states;

			statesProto = Object.assign({}, basicStates);
			statesProto = Object.assign(statesProto, states);
		}
		else 
		{
			statesProto = states;			
		}

		var bindsForElement = {};
		for(var key in elementsBinded) {
			bindsForElement[elementsBinded[key]] = key; 
		}

		// Create metadata:
		var metadata = new this.metadata(name);
		metadata.states = statesProto;
		metadata.statesLinked = statesLinked;
		metadata.statesInitial = statesInitial;
		metadata.elementsLinked = elementsLinked;
		metadata.elementsBinded = elementsBinded;
		metadata.bindsForElement = bindsForElement;

		if(numElements > 0) {
			metadata.elements = elements;
		}
		if(events.length > 0) {
			metadata.events = events;
		}

		proto._metadata = metadata;
		return proto;
	},

	compileBasicElement: function(props, extend)
	{
		var proto = this.genPrototype("basic", extend, props);

		proto.flagsInitial = (proto.Flag.ENABLED);
		proto.flags = proto.flagsInitial;

		this.element.basic.prototype = proto;
	},	

	compileElement: function(name, props, extend)
	{
		function element(parent, params) {
			wabi.element.basic.call(this, parent, params);
		};

		var elementProto = this.genPrototype(name, extend, props);

		element.prototype = Object.create(this.element.basic.prototype);
		element.prototype.constructor = element;
		var proto = element.prototype;

		for(var key in elementProto)
		{
			var p = Object.getOwnPropertyDescriptor(elementProto, key);
			if(p.get || p.set) {
				Object.defineProperty(proto, key, p);
				continue;
			}

			proto[key] = elementProto[key];
		}

		proto.deps = {};
		proto.depStates = {};

		// Generate setters:
		var metadata = elementProto._metadata;
		var statesLinked = metadata.statesLinked;
		var states = metadata.states;
		var statesProto = {};

		for(var key in statesLinked) 
		{
			if(!states[key]) {
				states[key] = undefined;
			}
		}

		for(var key in states) 
		{
			var stateValue = states[key];
			var stateValueType = typeof stateValue;

			var link = statesLinked[key];
			if(link) {
				statesProto[key] = null;
				this.defStateLink(proto, key, link);
			}
			else 
			{
				switch(stateValueType)
				{
					case "string":
					case "object":
						statesProto[key] = null;
						break;

					case "number":
						statesProto[key] = 0;
						break;

					case "boolean":
						statesProto[key] = false;
						break;

					default:
						console.warn("(wabi.compileElement) Unhandled stateValueType `" + stateValueType + "` for element: " + name);
						statesProto[key] = null;
						break;
				}

				this.defState(proto, key);
			}
		}

		function state() {};
		state.prototype = statesProto;
		metadata.stateCls = state;

		this.element[name] = element;
	},

	defState: function(proto, key)
	{
		Object.defineProperty(proto, "$" + key, 
		{
			set: function(value) {
				this._updateState(key, value);
			},
			get: function() 
			{
				let currDep = wabi.currDep;
				if(currDep) 
				{
					let buffer = currDep.buffer[key];
					if(!buffer) {
						buffer = [ currDep.key ];
						currDep.buffer[key] = buffer;
					}
					else {
						buffer.push(currDep.key);
					}
				}

				return this._$[key];
			}
		});	
	},

	defStateLink: function(proto, key, link)
	{
		Object.defineProperty(proto, "$" + key, 
		{
			set: function(value) 
			{
				var element = this.elements[link];
				if(element) {
					element.$value = value;
				}
				else {
					this._updateState(key, value);
				}
			},
			get: function() {
				return this.elements[link].$value;
			}
		});	
	},

	assignObj: function(target, src)
	{
		for(var key in src) 
		{
			var prop = Object.getOwnPropertyDescriptor(src, key);
			if(prop.get || prop.set) {
				Object.defineProperty(target, key, prop);
				continue;
			}

			target[key] = src[key];
		}
	},

	pushDependency(key, dep) 
	{
		let info = this.freeDependencies.pop();
		if(!info) {
			info = new this.Dependency(key, dep);
		}
		else {
			info.key = key;
			info.dep = dep;
		}

		this.currDep = info;
		this.dependencies.push(info);
	},

	popDependency() 
	{
		this.freeDependencies.push(this.dependencies.pop());
		this.currDep = this.dependencies[this.dependencies.length - 1] || null;
	},

	Dependency: function(key, buffer) {
		this.key = key;
		this.buffer = buffer;
	},

	metadata: function(name) 
	{
		this.name = name;
		this.states = null;
		this.stateCls = null;
		this.statesLinked = null;
		this.elements = null;
		this.elementsLinked = null;
		this.elementsBinded = null;
		this.events = null;
	},

	Watcher: function(owner, func) 
	{
		this.owner = owner ? owner : null,
		this.func = func;
	},

	Fragment: function(id, extend, props)
	{
		this.id = id;
		this.props = props;

		if(extend) 
		{
			if(typeof(extend) === "string") {
				this.extend = [ extend ];
			}
			else {
				this.extend = extend;
			}
		}
		else {
			this.extend = null
		}
	},

	ElementDef: function(props, extend)
	{
		this.props = props;
		this.extend = extend;
	},

	//
	globalData: {},

	elementsCached: {},
	elementDefs: {},

	dependencies: [],
	freeDependencies: [],
	currDep: null,

	fragments: {},
	templates: {},
	listeners: {}
};

"use strict";

"require wabi";

if(!window.wabi) {
	window.wabi = {};
}

wabi.data = function(raw, id, parent) 
{
	this.raw = raw ? raw : {};

	if(id !== undefined) {
		this.id = id;
	}
	else {
		this.id = "";
	}

	if(parent) {
		this.parent = parent;
	}
};

wabi.data.prototype = 
{
	set: function(key, value)
	{
		if(value === void(0)) 
		{
			if(wabi.dataProxy) 
			{
				wabi.dataProxy({ 
					id: this.genId(),
					type: "data",
					action: "set",
					value: key
				});
			} 
			else {
				this.performSet(key);
			}
		}
		else 
		{
			if(wabi.dataProxy) 
			{
				wabi.dataProxy({ 
					id: this.genId(),
					type: "data",
					action: "set",
					key: key,
					value: value
				});
			}
			else {
				this.performSetKey(key, value);
			}
		}
	},

	performSet: function(value) 
	{
		this.raw = value;

		if(this.watchers) 
		{
			var info;
			for(var n = 0; n < this.watchers.length; n++) {
				info = this.watchers[n];
				info.func.call(info.owner, "set", null, value, 0, this);
			}
		}
	},

	performSetKey: function(key, value) 
	{
		if(typeof value === "string") 
		{
			if(value[0] === "*") {
				var ref = new wabi.ref(value, key, this);
				this.raw[key] = ref;
				return ref;
			}
		}

		var index = key.indexOf(".");
		if(index === -1) 
		{
			if(value instanceof Object && !(value instanceof wabi.data)) {
				value = new wabi.data(value, key, this);
			}

			this.raw[key] = value;
		}
		else
		{
			var id;
			var data = this;
			var buffer = key.split(".");
			for(var n = 0; n < buffer.length - 1; n++) 
			{
				id = buffer[n];

				var currData = data.get(id);
				if(!currData) {
					currData = new wabi.data({}, id, data);
					data[id] = currData;
				}

				data = currData;
			}

			id = buffer[n];

			if(value instanceof Object && !(value instanceof wabi.data)) {
				value = new wabi.data(value, id, data);
			}

			data.raw[id] = value;
		}

		if(this.watchers) 
		{
			var info;
			for(var n = 0; n < this.watchers.length; n++) {
				info = this.watchers[n];
				info.func.call(info.owner, "set", key, value, 0, this);
			}
		}

		return value;
	},

	setKeys: function(value)
	{
		if(wabi.dataProxy) 
		{
			wabi.dataProxy({ 
				id: this.genId(),
				type: "data",
				action: "setkeys",
				value: value
			});
		}
		else {
			this.performSetKeys(value);
		}
	},	

	performSetKeys: function(value)
	{
		for(var key in value) {
			this.performSetKey(key, value[key]);
		}
	},

	add: function(key, value)
	{
		if(value === void(0)) 
		{
			if(wabi.dataProxy) 
			{
				wabi.dataProxy({ 
					id: this.genId(),
					type: "data",
					action: "add",
					value: key
				});
			}
			else {
				this.performAdd(key);
			}
		}
		else
		{
			if(wabi.dataProxy) 
			{
				wabi.dataProxy({ 
					id: this.genId(),
					type: "data",
					action: "add",
					key: key,
					value: value
				});
			}
			else {
				this.performAddKey(key, value);
			}
		}
	},

	push: function(key, value)
	{
		var buffer = this.get(key);
		if(!buffer) {
			buffer = new wabi.data([], "content", this);
			this.raw[key] = buffer;
		}
		else
		{
			if(!(buffer.raw instanceof Array)) {
				console.warn("(wabi.data) Key `" + key + "` is not an Array");
				return;
			}
		}

		buffer.add(value);
	},

	performAdd: function(value)
	{
		if(this.raw instanceof Array) 
		{
			if(value instanceof Object && !(value instanceof wabi.data)) {
				value = new wabi.data(value, this.raw.length + "", this);
			}

			this.raw.push(value);
		}
		else 
		{
			console.warn("(wabi.data.performAdd) Can peform add only to Array");
			return;
		}

		if(this.watchers) 
		{
			var info;
			for(var n = 0; n < this.watchers.length; n++) {
				info = this.watchers[n];
				info.func.call(info.owner, "add", null, value, -1, this);
			}
		}	
	},

	performAddKey: function(key, value)
	{
		if(this.raw instanceof Object) 
		{
			if(value instanceof Object && !(value instanceof wabi.data)) {
				value = new wabi.data(value, key, this);
			}
			else if(typeof value === "string" && value[0] === "*") {
				var ref = new wabi.ref(value, key, this);
				this.raw[key] = value;
				value = ref;
			}	

			this.raw[key] = value;
		}
		else 
		{
			console.warn("(wabi.data.performAddKey) Can peform add only to Object");
			return;
		}	

		if(typeof value === "string" && value[0] === "*") {
			var ref = new wabi.ref(value, key, this);
			this.raw[key] = value;
			value = ref;
		}	

		if(this.watchers) 
		{
			var info;
			for(var n = 0; n < this.watchers.length; n++) {
				info = this.watchers[n];
				info.func.call(info.owner, "add", key, value, -1, this);
			}
		}
	},

	remove: function(key)
	{
		// Remove self?
		if(key === undefined) {
			this.parent.remove(this.id);
		}
		else
		{
			if(wabi.dataProxy) 
			{
				wabi.dataProxy({ 
					id: this.genId(),
					type: "data",
					action: "remove",
					key: key
				});
			}
			else {
				this.performRemove(key);
			}
		}
	},

	performRemove: function(key)
	{
		var value = this.raw[key];
		delete this.raw[key];

		if(value instanceof wabi.data)
		{
			var refs = value.refs;
			if(refs)
			{
				for(var n = 0; n < refs.length; n++) {
					refs[n].$remove();
				}

				value.refs = null;
			}
		}
		else if(value instanceof wabi.ref) {
			value = value.instance;
		}

		if(this.watchers) 
		{
			var info;
			for(var n = 0; n < this.watchers.length; n++) {
				info = this.watchers[n];
				info.func.call(info.owner, "remove", key, value, -1, this);
			}
		}	
	},

	removeItem: function(key, id)
	{
		var item = this.raw[key];
		if(typeof(item) !== "object") {
			return;
		}

		if(item instanceof Array) {
			item.splice(id, 1);
		}
		else {
			delete item[id];
		}

		if(this.watchers) 
		{
			var info;
			for(var n = 0; n < this.watchers.length; n++) {
				info = this.watchers[n];
				info.func.call(info.owner, "removeItem", key, null, id, this);
			}
		}
	},

	get: function(index) 
	{
		if(index === "*") {
			return new wabi.data(this.raw, this.id, this.parent);
		}
		else if(index === "@") {
			return this.id;
		}

		var data;
		if(!isNaN(index) && index !== "") 
		{
			data = this.raw[index | 0];

			if(typeof(data) === "object" && !(data instanceof wabi.data)) {
				data = new wabi.data(data, index + "", this);
				this.raw[index] = data;
			}
		}
		else 
		{
			var cursor = index.indexOf(".");
			if(cursor === -1) 
			{
				data = this.raw[index];

				if(data)
				{
					if(typeof data === "object" && !(data instanceof wabi.data)) {
						data = new wabi.data(data, index + "", this);
						this.raw[index] = data;
					}
					else if(typeof data === "string" && data[0] === "*") {
						data = new wabi.ref(data, index, this);
						this.raw[index] = data;
						return data;
					}
				}
			}
			else
			{
				var buffer = index.split(".");
				data = this;
				for(var n = 0; n < buffer.length; n++)
				{
					data = data.getItem(buffer[n]);
				}
			}
		}

		return data;
	},

	getItem: function(id)
	{
		if(id === "*") {
			return new wabi.data(this.raw, this.id, this.parent);
		}

		var data;
		if(!isNaN(id) && id !== "") {
			data = this.raw[id | 0];
		}
		else 
		{
			data = this.raw[id];

			if(!data) {
				if(this.raw.content) {
					data = this.raw.content[id];
				}
			}
		}

		if(typeof(data) === "object" && !(data instanceof wabi.data)) {
			data = new wabi.data(data, id + "", this);
			this.raw[id] = data;
		}

		return data;
	},

	getFromKeys: function(keys)
	{
		var data = this;
		for(var n = 0; n < keys.length; n++) 
		{
			data = data.get(keys[n]);
			if(!data) {
				return null;
			}
		}

		return data;
	},

	genId: function()
	{
		if(!this.parent) { return this.id; }

		var id = this.id;
		var parent = this.parent;
		do 
		{
			if(!parent.id) { return id; }
			
			id = parent.id + "." + id;
			parent = parent.parent;
		} while(parent);

		return id;
	},

	watch: function(func, owner) 
	{
		if(!func) {
			console.warn("(wabi.data.watch) Invalid callback function passed");
			return;
		}
		if(!owner) {
			console.warn("(wabi.data.watch) Invalid owner passed");
			return;
		}

		if(this.watchers) {
			this.watchers.push(new this.Watcher(owner, func));
		}
		else {
			this.watchers = [ new this.Watcher(owner, func) ];
		}
	},

	unwatch: function(func, owner)
	{
		if(!this.watchers) { return; }

		var num = this.watchers.length;
		for(var n = 0; n < num; n++) 
		{
			var info = this.watchers[n];
			if(info.owner === owner && info.func === func) {
				this.watchers[n] = this.watchers[num - 1];
				this.watchers.pop();
				return;
			}
		}
	},

	sync: function() 
	{
		if(this.watchers) 
		{
			for(var n = 0; n < this.watchers.length; n++) {
				var info = this.watchers[n];
				info.func.call(info.owner, "sync", null, null, 0, this);
			}
		}	
	},

	__syncAsArray: function(data)
	{
		this.raw = data;

		if(this.watchers) 
		{
			for(var n = 0; n < this.watchers.length; n++) {
				var info = this.watchers[n];
				info.func.call(info.owner, "set", null, data, 0, this);
			}
		}	
	},

	__syncAsObject: function(data)
	{
		this.raw = {};

		for(var key in data)
		{
			var srcValue = this.raw[key];
			var targetValue = data[key];

			if(srcValue === void(0)) {
				this.raw[key] = targetValue;
			}
			else if(srcValue === targetValue) {
				srcValue = targetValue;
			}

			if(this.watchers) 
			{
				for(var n = 0; n < this.watchers.length; n++) {
					var info = this.watchers[n];
					info.func.call(info.owner, "set", key, targetValue, 0, this);
				}
			}
		}
	},

	removeRef: function(ref)
	{
		if(!this.refs) { 
			console.warn("(wabi.data.removeRef) No references created from this item");
			return;
		}

		var index = this.refs.indexOf(ref);
		this.refs[index] = this.refs[this.refs.length - 1];
		this.refs.pop();
	},

	toJSON: function() {
		return this.raw;
	},

	Watcher: function(owner, func) 
	{
		this.owner = owner ? owner : null,
		this.func = func;
	},

	//
	watchers: null,
	parent: null,
	refs: null
};

wabi.ref = function(path, id, parent) 
{
	this.id = id;
	this.path = path;
	this.parent = parent;

	var refPath = path.slice(1);
	this.instance = wabi.globalData.raw.assets.get(refPath);

	if(this.instance)
	{
		if(this.instance.refs) {
			this.instance.refs.push(this);
		}
		else {
			this.instance.refs = [ this ];
		}
	}
	else {
		console.warn("(wabi.ref) Invalid ref: " + refPath);
	}
};

wabi.ref.prototype = 
{
	remove: function()
	{
		this.instance.removeRef(this);
		this.instance = null;
		this.parent.remove(this.id);
	},

	$remove: function() {
		this.parent.remove(this.id);
	},

	toJSON: function() {
		return this.path;
	}
};

"use strict";

"require ../wabi";

// TODO (maybe): If data or binding is removed reset value?
// TODO: Check if child items can click through

wabi.element.basic = function(parent, params)
{
	if(this.create) {
		this.create(params);
	}
	
	if(!this.domElement) {
		this.domElement = document.createElement(this.tag ? this.tag : this._metadata.name);
	}

	this.domElement.holder = this;
	this._$ = new this._metadata.stateCls();

	if(parent) {
		this.parent = parent;
	}

	// Load events:
	var events = this._metadata.events;
	if(events)
	{
		for(var n = 0; n < events.length; n++) {
			this._addEvent(events[n]);
		}		
	}

	if(this.prepare) {
		this.prepare();
	}
};

wabi.element("basic", 
{
	create: null,

	element: function(slotId, element)
	{
		var elementSlot = this._metadata.elements[slotId];
		if(!elementSlot) {
			console.warn("(wabi.element.basic.element) Invalid slot id: " + slotId);
			return null;
		}

		if(!element) 
		{
			var prevElement = this.elements[slotId];
			if(prevElement) {
				prevElement.remove();
			}

			this.elements[slotId] = null;
			return null;
		}

		if(typeof element === "string")
		{
			element = wabi.createElement(element);
			if(!element) { 
				this.elements[slotId] = null;
				return null; 
			}
		}
		else if(!(element instanceof wabi.element.basic)) {
			console.warn("(wabi.element.basic.element) Invalid element passed should be string or extend `wabi.element.basic`");
			this.elements[slotId] = null;
			return null;
		}

		var params = elementSlot.params;
		for(var key in params) {
			element[key] = params[key];
		}

		element.flags |= (this.Flag.SLOT);
		element.slotId = slotId;
		this.elements[slotId] = element;

		var watch = elementSlot.watch;
		for(var key in watch) 
		{
			var funcName = watch[key];
			var func = this[funcName];
			if(!func) 
			{
				console.warn("(wabi.element.basic.element) Slot `" + slotId + "` watching on `" + 
					key + "` uses undefined function: " + funcName);
				continue;
			}

			element.watch(key, func, this);
		}

		var parentLink = this._metadata.elementsLinked[slotId];
		if(parentLink) {
			element._parentLink = parentLink;
			this._$[parentLink] = element;
		}

		var binds = this._metadata.elementsBinded[slotId];
		if(binds) {
			element.bind = binds;
		}	

		if(elementSlot.state) {
			element.$ = elementSlot.state;
		}

		var elementBefore = this.domElement.childNodes[elementSlot.slot];
		if(elementBefore) {
			this.appendBefore(element, elementBefore.holder);
		}
		else {
			element.appendTo(this);
		}

		return element;
	},	

	_setup: function()
	{
		// Create elements:
		var elements = this._metadata.elements;
		if(elements) 
		{
			if(!this.elements) {
				this.elements = {};
			}
			
			for(var key in elements) {
				this.element(key, elements[key].type);
			}
		}

		// Process initial state:
		if(this.flags & this.Flag.INITIAL_SETUP_DONE) 
		{
			var states = this._metadata.states;
			for(var key in states) {
				this._processState(key, states[key]);
			}
		}
		else 
		{
			var states = this._metadata.statesInitial;
			for(var key in states) {
				this._processState(key, states[key], true);
			}

			this.flags |= this.Flag.INITIAL_SETUP_DONE;
		}

		if(this.setup) {
			this.setup();
		}		
	},

	prepare: null,

	setup: null,

	append: function(element) {
		element.appendTo(this);
	},

	appendTo: function(parent)
	{
		if(!parent) {
			return console.warn("(wabi.element.basic.appendTo) Invalid parent passed");
		}

		if(this._parent) {
			return console.warn("(wabi.element.basic.appendTo) Element is already added to different parent");
		}

		var parentHolder;
		if(parent instanceof Element) 
		{
			parentHolder = parent.holder;
			if(!parentHolder) {
				parentHolder = wabi.createElement("wrapped", null, parent);
				parent.holder = parentHolder;
			}
		}
		else {
			parentHolder = parent;
		}

		if(!parentHolder.children) {
			parentHolder.children = [ this ];
		}
		else {
			parentHolder.children.push(this);
		}

		this._parent = parentHolder;

		if(parentHolder._data && parentHolder.bind !== "*") 
		{
			if(!this.region) { 
				this.data = parentHolder._data;
			}
		}
		
		if(parentHolder.domElement && (this.flags & this.Flag.ENABLED)) {
			parentHolder.domElement.appendChild(this.domElement);
		}
	},

	appendBefore: function(element, elementBefore)
	{
		if(!this.children) {
			return console.error("(wabi.element.")
		}
		else {
			this.children.push(element);
		}

		if(this._data && this.bind !== "*") 
		{
			if(!element.region) { 
				element.data = this._data;
			}
		}

		element._parent = this;

		if(this.flags & this.Flag.ENABLED) {
			this.domElement.insertBefore(element.domElement, elementBefore.domElement);
		}
	},

	_remove: function()
	{
		if(this.cleanup) {
			this.cleanup();
		}

		this.removeAll();

		if(this.flags & this.Flag.ENABLED) 
		{
			if(this._parent) {
				this._parent.domElement.removeChild(this.domElement);
			}
		}

		if(this._parent) 
		{
			var parentChildren = this._parent.children;
			var index = parentChildren.indexOf(this);
			if(index > -1) {
				parentChildren[index] = parentChildren[parentChildren.length - 1];
				parentChildren.pop();
			}

			if(this._parentLink) {
				this._parent._$[this._parentLink] = null;
				this._parentLink = null;
			}
			
			if(this.slotId) {
				this._parent.elements[this.slotId] = null;
				this.slotId = null;
			}

			if(this._parent.onChildRemove) {
				this._parent.onChildRemove(this);
			}
			
			this._parent = null;
		}

		if(this._data) {
			this.data = null;
		}

		if(this.domElement.className) {
			this.domElement.className = "";
		}
		
		while(this.domElement.attributes.length > 0) {
			this.domElement.removeAttribute(this.domElement.attributes[0].name);
		}

		this.flags = 0;
		this._bind = null;
		if(this._watching) { this._watching = null; }
		if(this.listeners) { this.listeners = null; }
		if(this.childrenListeners) { this.childrenListeners = null; }
	},

	removeAll: function()
	{
		if(this.children) 
		{
			for(var n = this.children.length - 1; n > -1; n--) {
				wabi.removeElement(this.children[n]);
			}
		}
	},

	remove: function() {
		wabi.removeElement(this);
	},

	removeChildWithData: function(data) 
	{
		if(!this.children) { return; }

		for(var n = 0; n < this.children.length; n++) {
			var child = this.children[n];
			if(child.data === data) {
				child.remove();
			}
		}
	},

	onChildRemove: null,

	attrib: function(key, value)
	{
		if(value === void(0)) {
			return this.domElement.getAttribute(key);
		}
		else {
			this.domElement.setAttribute(key, value);
		}
		
		return value;
	},

	removeAttrib: function(key) {
		this.domElement.removeAttribute(key);
	},

	style: function(key, value)
	{
		if(this.domElement.style[key] === void(0)) {
			console.warn("(wabi.element.basic.style) Invalid DOM style:", key);
			return null;
		}

		if(value === void(0)) {
			return this.domElement.style[key];
		}
		else {
			this.domElement.style[key] = value;
		}
		
		return value;
	},

	removeStyle: function(key) {
		this.domElement.style.removeProperty(key);
	},

	setCls: function(name, state) 
	{
		if(state) {
			this.domElement.classList.add(name);
		}
		else {
			this.domElement.classList.remove(name);
		}
	},

	get: function(id) 
	{
		if(id[0] === "#")
		{
			var domElement = this.domElement.querySelector(id);
			if(domElement) {
				return domElement.holder;
			}
		}
		else
		{
			if(typeof id === "function")
			{
				var tag = id.prototype.tag || id.prototype._metadata.name;

				var buffer = this.domElement.querySelectorAll(tag);
				var num = buffer.length;
				if(num > 0) 
				{
					var holderBuffer = new Array(num);
					for(var n = 0; n < num; n++) 
					{
						if(buffer[n].holder instanceof id) {
							holderBuffer[n] = buffer[n].holder;
						}
					}

					return holderBuffer;
				}
			}
			else
			{
				var buffer = this.domElement.querySelectorAll(id);
				var num = buffer.length;
				if(num > 0) 
				{
					var holderBuffer = new Array(num);
					for(var n = 0; n < num; n++) {
						holderBuffer[n] = buffer[n].holder;
					}

					return holderBuffer;
				}
			}
		}

		return null;
	},

	on: function(event, id, cb, owner)
	{
		if(id === undefined) {
			console.warn("(wabi.element.basic.on) Invalid callback passed to event: " + event);
			return;
		}

		if(typeof(id) === "function") {
			owner = cb;
			cb = id;
			id = null;
		}

		if(!cb) {
			console.warn("(wabi.element.basic.on) Invalid callback function: " + event);
			return;
		}

		var element, listeners;

		if(id)
		{
			if(typeof(id) === "string" && id[0] === "#")
			{
				element = this.get(id);
				if(!element) { return; }
			}
			else
			{
				if(!this.childrenListeners) {
					this.childrenListeners = {};
				}

				if(id instanceof Array) 
				{
					for(var n = 0; n < id.length; n++) {
						this._onChildListen(event, id[n], cb, owner);
					}
				}
				else {
					this._onChildListen(event, id, cb, owner)
				}

				return;
			}	
		}
		else
		{
			element = this;	
		}

		listeners = element.listeners;
		if(!listeners) {
			listeners = {};
			element.listeners = listeners;
		}

		var buffer = listeners[event];
		if(!buffer) {
			buffer = [];
			listeners[event] = buffer;
			element._addEvent(event);
		}

		buffer.push(cb.bind(owner));			
	},

	emit: function(eventName, domEvent)
	{
		var event;

		if(this.listeners)
		{
			var buffer = this.listeners[eventName];
			if(buffer)
			{
				event = new wabi.event(eventName, this, domEvent);
				if(this._preventableEvents[eventName]) {
					domEvent.preventDefault();
				}

				for(var n = 0; n < buffer.length; n++) {
					buffer[n](event);
				}
			}
		}

		// if(this._parent) 
		// {
		// 	if(!event) 
		// 	{
		// 		event = new wabi.event(eventName, this, domEvent);
		// 		if(this._$preventableEvents[eventName]) {
		// 			domEvent.preventDefault();
		// 		}
		// 	}

		// 	this.checkParentListeners(eventName, event);
		// }
	},

	emitEx: function(event)
	{
		if(!this.listeners) { return; }

		var buffer = this.listeners[event.name];
		if(!buffer) { return; }

		for(var n = 0; n < buffer.length; n++) {
			buffer[n](event);
		}
	},

	checkParentListeners: function(eventName, event)
	{
		var buffer = this.childrenListeners[eventName];
		if(buffer)
		{
			for(var n = 0; n < buffer.length; n++) {
				buffer[n](event);
			}
		}

		if(this._parent) {
			this.checkParentListeners(eventName, event);
		}
	},

	_onChildListen: function(event, id, cb, owner)
	{
		var map = this.childrenListeners[id];
		if(!map) {
			map = {};
			this.childrenListeners[id] = map;
		}

		var buffer = map[event];
		if(!buffer) {
			buffer = [ cb.bind(owner) ];
			map[event] = buffer;
		}
		else {
			buffer.push(cb.bind(owner));
		}

		if(this.domElement["on" + event] === null) {
			this._addEvent(event);
		}
	},

	off: function(event, owner)
	{

	},

	set id(id) 
	{
		if(id) {
			this.domElement.id = id;
		}
		else {
			this.domElement.removeAttribute("id");
		}
	},

	get id() {
		return this._id;
	},

	set bind(bind)
	{
		if(bind)
		{
			var element;
			var statesLinked = this._metadata.statesLinked;

			if(typeof(bind) === "string") 
			{
				var element = statesLinked.value;
				if(element !== undefined)
				{
					element = this.elements[element];
					if(element) {
						element.bind = bind;
						bind = null;
					}					
				}
			}
			else 
			{
				for(var key in bind)
				{
					var elementLinked = statesLinked[key];
					if(elementLinked !== undefined) 
					{
						var element = this.elements[elementLinked];
						if(element) {
							element.bind = bind[key];
							delete bind[key];
						}
					}
				}
			}
		}

		this._bind = bind;
		this.updateBindings();
	},

	get bind() {
		return this._bind;
	},

	set hidden(value)
	{
		if(value) 
		{
			if(this.flags & this.Flag.HIDDEN) { return; }
			this.flags |= this.Flag.HIDDEN;

			this.domElement.classList.add("hidden");
		}
		else 
		{
			if((this.flags & this.Flag.HIDDEN) === 0) { return; }
			this.flags &= ~this.Flag.HIDDEN;

			this.domElement.classList.remove("hidden");
		}
	},

	get hidden() {
		return ((this.flags & this.Flag.HIDDEN) === this.Flag.HIDDEN);
	},

	set enabled(value)
	{
		if(value) 
		{
			if(this.flags & this.Flag.ENABLED) { return; }
			this.flags |= this.Flag.ENABLED;

			if(this._parent) {
				this._parent.domElement.appendChild(this.domElement);
			}
		}
		else 
		{
			if((this.flags & this.Flag.ENABLED) === 0) { return; }
			this.flags &= ~this.Flag.ENABLED;

			if(this._parent) {
				this._parent.domElement.removeChild(this.domElement);
			}
		}
	},

	get enabled() {
		return ((this.flags & this.Flag.ENABLED) === this.Flag.ENABLED);
	},

	set $(state)
	{
		if(typeof(state) === "object")
		{
			for(var key in state) {
				this.setState(key, state[key]);
			}
		}
		else {
			this.setState("value", state);
		}
	},

	get $() {
		return this._$;
	},

	set parent(parent)
	{	
		if(this._parent === parent) { return; }

		if(parent) {
			this.appendTo(parent);
		}
		else 
		{
			if(this._parent) {
				this._parent.remove(this);
			}
		}
	},

	get parent() {
		return this._parent;
	},

	set data(data)
	{
		if(data instanceof wabi.ref)
		{
			if(this._data === data.instance) { return; }

			if(this._data && this.flags & this.Flag.WATCHING) 
			{
				this.flags &= ~this.Flag.WATCHING;
				this._data.unwatch(this.handleDataChange, this);
			}

			this._data = data.instance;
			this.ref = data;
		}
		else 
		{
			if(this._data === data) { return; }

			if(this._data && this.flags & this.Flag.WATCHING) 
			{
				this.flags &= ~this.Flag.WATCHING;
				this._data.unwatch(this.handleDataChange, this);
			}

			this._data = data;
		}

		this.updateBindings();
		
		if(this.children)
		{
			for(var n = 0; n < this.children.length; n++) 
			{
				var child = this.children[n];
				if(child.region) { continue; }

				child.data = data;
			}
		}
	},

	get data() {
		return this._data;
	},

	html: function(value) 
	{
		if(value === undefined) {
			return this.domElement.innerHTML;
		}

		if(this.children && this.children.length > 0) {
			console.warn("(wabi.element.basic.html) Can`t set html content for element `" + this._metadata.name + "` that has children");
			return null;
		}

		this.domElement.innerHTML = value
		return value;
	},

	updateBindings: function()
	{
		if(this._data)
		{
			if(this._bind)
			{
				if((this.flags & this.Flag.WATCHING) === 0) {
					this.flags |= this.Flag.WATCHING;
					this._data.watch(this.handleDataChange, this);
				}
				
				if(typeof(this._bind) === "string") {
					this.updateDataValue("value", this._bind);
				}
				else
				{
					for(var key in this._bind) {
						this.updateDataValue(key, this._bind[key]);
					}
				}
			}
			else
			{
				if(this._data && this.flags & this.Flag.WATCHING) {
					this.flags &= ~this.Flag.WATCHING;
					this._data.unwatch(this.handleDataChange, this);
				}				
			}
		}
	},

	updateDataValue: function(key, bind)
	{
		var value = this._data.get(bind);
		if(value !== undefined) {
			this.setState(key, value);
		}
		else {
			// this.setState(key, (this._$.value !== undefined) ? this._$.value : null);
		}		
	},

	_addEvent: function(eventName) 
	{
		var func = this["handle_" + eventName];

		if(eventName === "click") 
		{
			this.domElement.onclick = this._processClick.bind(this);
			if(func) {
				this._onClick = func.bind(this);
			}
		}
		else if(eventName === "dblclick") 
		{
			this.domElement.onclick = this._processClicking.bind(this);
			if(func) {
				this._onDblClick = func.bind(this);
			}
		}
		else 
		{
			var eventKey = "on" + eventName;

			if(this.domElement[eventKey] === null) 
			{
				var self = this;
				this.domElement[eventKey] = function(domEvent) {
					self._processEvent(eventName, func, domEvent);
				}
			}
		}
	},

	_onClick: null,

	_onDblClick: null,

	_processClick: function(domEvent)
	{
		var event = new wabi.event("click", this, domEvent);

		var element = domEvent.target.holder;
		if(element && element !== this) 
		{
			this._processChildEvent(element._metadata.name, event);
			this._processChildEvent("*", event);
		}

		if(this._onClick) {
			this._onClick(event);
		}

		this.emitEx(event);
	},

	_processClicking: function(domEvent)
	{
		var event;
		if(domEvent.detail % 2 === 0) {
			event = new wabi.event("dblclick", this, domEvent);
		}
		else {
			event = new wabi.event("click", this, domEvent);
		}

		var element = domEvent.target.holder;
		if(element !== this) 
		{
			event.element = element;

			this._processChildEvent(element._metadata.name, event);
			this._processChildEvent("*", event);
			return;
		}

		if(domEvent.detail % 2 === 0) 
		{
			if(this._onDblClick) {
				this._onDblClick(event);
			}

			this.emitEx(event);
		}
		else 
		{
			if(this._onClick) {
				this._onClick(event);
			}

			this.emitEx(event);
		}
	},

	_processEvent: function(eventName, func, domEvent)
	{
		var event = new wabi.event(eventName, this, domEvent);
		if(this._preventableEvents[eventName]) {
			domEvent.preventDefault();
			domEvent.stopPropagation();
		}		

		var element = domEvent.target.holder;
		if(element !== this) 
		{
			event.element = element;

			this._processChildEvent(element._metadata.name, event);
			this._processChildEvent("*", event);
			return;
		}

		if(func) {
			func.call(this, event);
		}
		
		this.emitEx(event);		
	},

	_processChildEvent: function(id, event)
	{
		if(!this.childrenListeners) { return; }

		var map = this.childrenListeners[id];
		if(!map) { return; }

		var buffer = map[event.name];
		if(buffer)
		{
			for(var n = 0; n < buffer.length; n++) {
				buffer[n](event);
			}

			return;
		}		
	},

	handleDataChange: function(action, key, value, id)
	{
		var bind = this._bind;
		var type = typeof(bind);

		if(type === "string") 
		{
			if(key !== bind && bind !== "*") { return; }

			this._setActionState(action, "value", value, id);
		}
		else if(type === "object")
		{
			if(bind[key] === void(0)) { return; }

			this._setActionState(action, bind[key], value, id);
		}
	},

	_updateParentStateFunc: function(key, value)
	{
		if(this._parentLink && key === "value") {
			value = this._parent._updateParentStateFunc(this._parentLink, value);
		}

		const func = this["set_" + key];
		if(func) 
		{
			const haveDepsHandled = this.deps[key];
			if(!haveDepsHandled) 
			{
				let deps = this.depStates;
				if(!deps) {
					deps = {};
					this.depStates = deps;
				}

				this.deps[key] = true;
				wabi.pushDependency(key, deps);
			}

			const newValue = func.call(this, value);
			if(newValue !== undefined) {
				value = newValue;
			}

			if(!haveDepsHandled) {
				wabi.popDependency();
			}
		}

		if(this.watching)
		{
			const func = this.watching[key];
			if(func) {
				func.call(this._parent, value);
			}
		}

		return value;
	},

	_updateState: function(key, value)
	{
		if(this._parentLink && key === "value") {
			value = this._parent._updateParentStateFunc(this._parentLink, value);
		}

		if(this._data && this._bind) 
		{
			if(typeof(this._bind) === "string")
			{
				if(key === "value") {
					this._data.set(this._bind, value);
				}
				else {
					this._setActionState("set", key, value);
				}
			}
			else
			{
				var dataBindName = this._bind[key];
				if(dataBindName) {
					data.set(dataBindName, value);
				}
				else {
					this._setActionState("set", dataBindName, value);
				}
			}
		}
		else 
		{
			this._setActionState("set", key, value);
		}
	},

	_setActionState: function(action, key, value, index)
	{
		if(this._$[key] === undefined) { return; }

		var func = this[action + "_" + key];
		if(func) 
		{
			var newValue = func.call(this, value);
			if(newValue !== undefined) {
				value = newValue;
			}
		}

		if(this.watching)
		{
			var func = this.watching[key];
			if(func) {
				func.call(this._parent, value);
			}
		}

		if(action === "set") {
			this._$[key] = value;
		}

		const dep = this.depStates[key];
		if(dep)
		{
			for(let n = 0; n < dep.length; n++) {
				let depsKey = dep[n];
				this._updateState(depsKey, this.$[depsKey]);
			}
		}
	},

	setState: function(key, value)
	{
		var stateValue = this._$[key];
		if(stateValue === undefined) { return; }

		if(this._parentLink && key === "value") {
			value = this._parent.setStateParent(this._parentLink, value);
		}

		var func = this["set_" + key];
		if(func) 
		{
			var newValue = func.call(this, value);
			if(newValue !== undefined) {
				value = newValue;
			}
		}

		if(stateValue instanceof wabi.element.basic) {
			stateValue.setState("value", value);
		}
		else 
		{
			if(this.watching)
			{
				var func = this.watching[key];
				if(func) 
				{
					var newValue = func.call(this._parent, value);
					if(newValue !== undefined) {
						value = newValue;
					}
				}
			}

			this._$[key] = value;
		}
	},

	setStateParent: function(key, value)
	{
		if(this._parentLink && key === "value") {
			value = this._parent.setStateParent(this._parentLink, value);
		}

		var func = this["set_" + key];
		if(func) {
			func.call(this, value);
		}
		
		return value;
	},

	_processState: function(key, value, initial)
	{
		if(value === undefined) { return; }

		if(!initial && this._$[key] === value) { return; }

		var func = this["set_" + key];
		if(func) 
		{
			const haveDepsHandled = this.deps[key];
			if(!haveDepsHandled) 
			{
				let deps = this.depStates;
				if(!deps) {
					deps = {};
					this.depStates = deps;
				}

				this.deps[key] = true;
				wabi.pushDependency(key, deps);
			}

			var newValue = func.call(this, value);
			if(newValue !== undefined) {
				value = newValue;
			}

			if(!haveDepsHandled) {
				wabi.popDependency();
			}
		}

		var elementKey = this._metadata.statesLinked[key];
		if(elementKey) {
			return this.elements[elementKey]._processState("value", value);
		}
		else 
		{
			if(this.watching)
			{
				var func = this.watching[key];
				if(func) {
					func.call(this._parent, value);
				}
			}

			this._$[key] = value;
		}

		return value;
	},

	watch: function(name, func)
	{
		if(!this.watching) {
			this.watching = {};
		}

		this.watching[name] = func;
	},

	unwatch: function(name, func)
	{
		if(this.watching[name]) {
			this.watching[name] = null;
		}
	},

	toJSON: function() {
		return this._$;
	},

	Flag: {
		NONE: 0,
		ENABLED: 1 << 1,
		WATCHING: 1 << 2,
		ELEMENT: 1 << 3,
		SLOT: 1 << 4,
		HIDDEN: 1 << 5,
		INITIAL_SETUP_DONE: 1 << 6
	},

	//
	_metadata: null,
	elements: null,
	domElement: null,

	_id: "",
	_$: null,
	_parent: null,
	_data: null,
	_bind: null,
	ref: null,
	_parentLink: null,

	slotId: null,

	watchers: null,
	watching: null,

	flags: 0,
	tag: null,

	listeners: null,
	children: null,
	childrenListeners: null,
	_preventableEvents: {
		"contextmenu": true
	},
	
	region: false
});

Element.prototype.holder = null;

"use strict";

wabi.element("button",
{
	set_value: function(value) {
		this.html(value);
	},

	set_width: function(value) 
	{
		if(value > 0) {
			this.style("flex", "1 1 " + value + "px");
		}
		else if(this.style("flex")) {
			this.style("flex", "");
		}
	},

	//
	width: 0
});

"use strict";

wabi.element("canvas", 
{
	prepare: function() {
		this.ctx = this.domElement.getContext("2d");
	},

	//
	ctx: null
});
"use strict";

wabi.element("caret", 
{
	state: {
		value: true
	},

	setup: function() {
		this.setCls("fa", true);
	},

	toggle: function() {
		this.$value = !this.$value;
	},

	set_value: function(value)
	{
		if(value) {
			this.setCls("fa-caret-right", false);
			this.setCls("fa-caret-down", true);
		}
		else {
			this.setCls("fa-caret-down", false);
			this.setCls("fa-caret-right", true);
		}
	},

	handle_click: function(event) {
		this.toggle();
	}
});

"use strict";

wabi.element("checkbox", 
{
	state: {
		value: false
	},

	setup: function() {
		this.attrib("tabindex", "0");
	},

	set_value: function(value) {
		this.setCls("active", value);
	},

	handle_click: function() {
		this.toggle();
	},

	handle_keydown: function(event) 
	{
		if(event.domEvent.keyCode === 32) {
			this.toggle();
		}
	},

	toggle: function() {
		this.$value = !this.$value;
	}
});

"use strict";

wabi.element("content", 
{
	set_value: function(value) 
	{
		this.removeAll();

		this.$loadValue(value);
	},

	$loadValue: function(value)
	{
		if(!value) { return; }

		var type = typeof(value);
		
		if(type === "object")
		{
			if(value instanceof Array)
			{
				for(var n = 0; n < value.length; n++)
				{
					var state = value[n];
					if(typeof(state) === "string") 
					{
						var template = wabi.getFragment(state);
						this.$loadValue(template);
					}
					else {
						this.$loadState(state);
					}
				}	
			}
			else {
				this.$loadState(value);
			}
		}
		else 
		{
			var template = wabi.getFragment(value);
			this.$loadValue(template);
		}		
	},

	$loadState: function(state)
	{
		if(!state.type) {
			console.warn("(wabi.elements.content) Undefined element type");
			return;
		}

		var element = wabi.createElement(state.type, this);
		if(!element) { return; }

		for(var key in state)
		{
			if(key === "type") { continue; }

			element[key] = state[key];
		}
	},

	set padding(value) 
	{
		if(value > 0) {
			this.style("margin", value + "px");
		}
		else if(this.style("margin")) {
			this.style("margin", "");
		}
	},

	get padding() {
		return this._padding;
	},

	set height(value) 
	{
		this.style("height", value + "px");
	},

	get height() {
		return this._height;
	},

	//
	_padding: 0,
	_height: 0	
});
"use strict";

wabi.element("desc",
{
	elements: 
	{
		content: {
			type: "content",
			link: "value"
		},
		name: {
			type: "text",
			link: "name"
		}
	}
});


"use strict";

wabi.element("div", {});
"use strict";

wabi.element("dropdown",
{
	state: 
	{
		value: "",
		dataset: null,
		filter: null,
		sort: false,
		emptyOption: false		
	},

	elements: 
	{
		input: {
			type: "staticInput",
			bind: "value",
			region: true
		},
		caret: {
			type: "icon",
			$value: "fa-caret-down"
		},
		list: "list"
	},

	setup: function()
	{
		this.elements.list.on("click", this.selectOption, this);
		
		this.on("click", "staticInput", this.openMenu, this);
		wabi.on("click", this.hideMenu, this);
	},

	cleanup: function()
	{
		wabi.off("click", this.hideMenu, this);
	},

	set_value: function(value)
	{
		if(this._dataset)
		{
			var data = this._dataset.get(value);
			if(!data) {
				this.elements.input.data = null;
				this.elements.input.$value = "";
				return "";
			}

			this.elements.input.data = data;
		}
		else {
			this.elements.input.data = null;
			this.elements.input.$value = "";
			return "";
		}
	},

	set_dataset: function(value)
	{
		if(!value) {
			this._dataset = null;
			return;
		}

		this._dataset = wabi.globalData.get(value);
		if(!this._dataset) {
			console.log("(wabi.element.dropdown.set_dataset) Data set not found: " + value);
			return;
		}
	},

	openMenu: function(event)
	{
		event.stop();

		var list = this.elements.list;
		list.removeAll();

		if(!this._dataset) { return; }

		list.$value = this.genDataBuffer();
		list.hidden = false;
	},

	genDataBuffer: function()
	{
		var buffer = {};
		var data = new wabi.data(buffer);
		var raw = this._dataset.raw;

		if(this.$emptyOption) {
			buffer[""] = { value: "" };
		}

		for(var key in raw) {
			buffer[key] = raw[key];
		}

		return data;
	},

	hideMenu: function(event) {
		this.elements.list.hidden = true;
	},

	selectOption: function(event)
	{
		event.stop();

		this.$value = this.elements.list.cache.selected.data.id;
		this.hideMenu();
	},

	//
	_dataset: null,
});

"use strict";

wabi.element("error", 
{
	state: {
		types: {}
	},

	set_value: function(value)
	{
		if(!value) {
			this.html("");
			return;
		}

		var text = this.$types[value];
		if(!text) {
			this.html("");
			return; 
		}

		this.html(text);
	},

	set_types: function(value)
	{
		if(this.$value) {
			this.set_value(this.$value);
		}
	}
});

"use strict";

wabi.element("group", 
{
	params: {
		padding: 2
	},

	set_value: function(value) 
	{

	},

	set_padding: function(value) {
		this.style("margin", value + "px");
	}
})
"use strict";

wabi.element("header", 
{
	set_value: function(value) {
		this.html(value);
	}
});

"use strict";

wabi.element("headerEx",
{
	elements: 
	{
		caret: {
			type: "caret",
			link: "open"
		},
		text: {
			type: "text",
			link: "value"
		}
	},

	prepare: function() {
		this.on("click", "*", this.handle_click, this);
	},

	handle_click: function(event) {
		this.elements.caret.toggle();
	},

	//
	tag: "header"
});

"use strict";

wabi.element("html", 
{
	set_value: function(value)
	{
		// TODO: parse by tokens
		this.domElement.innerHTML = value;

		var iter = document.createNodeIterator(this.domElement, NodeFilter.SHOW_TEXT);
		var currNode, text, name, firstIndex, lastIndex;
		while(currNode = iter.nextNode()) 
		{
			text = currNode.nodeValue; 

			firstIndex = text.indexOf("{");
			if(firstIndex === -1) { continue; }

			lastIndex = text.indexOf("}");
			if(lastIndex === -1) { continue; }

			name = text.slice(firstIndex + 1, lastIndex);
			this.genStateFuncs(name);
		}
	},

	// genStateFuncs_HTML: function(name, element) 
	// {
	// 	var self = this;

	// 	if(this._stateValues[name]) {
	// 		element.innerHTML = this._stateValues[name];
	// 	}
	// 	else {
	// 		element.innerHTML = "";
	// 	}

	// 	Object.defineProperty(this._state, name, {
	// 		set: function(value) 
	// 		{
	// 			if(self._stateValues[name] === value) { return; }
	// 			self._stateValues[name] = value;

	// 			if(self._data && self._bind && self._bind[name]) {
	// 				self._data
	// 			}

	// 			element.innerHTML = value;
	// 		},
	// 		get: function() {
	// 			return self._stateValues[name];
	// 		},
	// 		enumerable: true,
	// 		configurable: true
	// 	});		
	// },		
});

"use strict";

wabi.element("icon", 
{
	setup: function() 
	{
		this.hidden = true;
		this.attrib("class", "fa");
	},

	set_value: function(value, prevValue) 
	{
		this.setCls(value, true);
		this.hidden = false;
	}
});
"use strict";

wabi.element("iframe",
{
	// $addEvent: function(eventName) 
	// {
	// 	var func = this.$wnd["handle_" + eventName];

	// 	if(eventName === "click") 
	// 	{
	// 		this.$domElement.onclick = this.$processClick.bind(this);
	// 		if(func) {
	// 			this.$onClick = func.bind(this);
	// 		}
	// 	}
	// 	else if(eventName === "dblclick") 
	// 	{
	// 		this.$domElement.onclick = this.$processClicking.bind(this);
	// 		if(func) {
	// 			this.$onDblClick = func.bind(this);
	// 		}
	// 	}
	// 	else 
	// 	{
	// 		var eventKey = "on" + eventName;

	// 		if(this.$domElement[eventKey] === null) 
	// 		{
	// 			var self = this;
	// 			this.$domElement[eventKey] = function(domEvent) {
	// 				self.$processEvent(eventName, func, domEvent);
	// 			}
	// 		}
	// 	}
	// },

	set_value: function(value) {
		this.domElement.src = value;
	},

	handle_load: function(event) {
		this.wnd = this.domElement.contentWindow;
	},

	//
	wnd: null
});

"use strict";

wabi.element("input", 
{
	set_value: function(value) {
		this.domElement.value = value;
	},

	set inputType(value) {
		this.attrib("type", value);
	},

	get inputType() {
		return this.attrib("type");
	},

	set placeholder(value) 
	{
		if(value) {
			this.domElement.placeholder = value;
		}
		else {
			this.domElement.placeholder = "";
		}
	},

	get placeholder() {
		return this.domElement.placeholder;
	},

	set readOnly(value) {
		this.domElement.readOnly = value;
	},

	get readOnly() {
		return this.domElement.readOnly;
	},

	set editable(value) 
	{
		if(value) {
			this.removeAttrib("readonly");
		}
		else {
			this.attrib("readonly", "");
		}
	},

	get editable() {
		return (this.attrib("readonly") === undefined);
	},

	handle_change: function(event) {
		this.$value = this.domElement.value;
	},

	//
	tag: "input"
});

wabi.element("staticInput", "input",
{
	setup: function() {
		this.editable = false;
	}
});

"use strict";

wabi.element("label",
{
	elements: 
	{
		name: {
			type: "text",
			link: "name"
		},
		content: {
			type: "content",
			link: "value"
		}
	}
});

"use strict";

wabi.element("list",
{
	setup: function()
	{
		this.cache = {
			itemElements: [],
			selectable: true,
			selected: null, 
			dragging: null
		};
	},

	set_value: function(value) 
	{
		this.removeAll();

		if(value) 
		{
			this.set_placeholder(null);

			if(value instanceof Object)
			{
				if(value instanceof Array)
				{
					for(var n = 0; n < value.length; n++) {
						this.add_value(value.get(n));
					}
				}
				else
				{
					var raw = value.raw;
					for(var key in raw) {
						this.add_value(value.get(key));
					}
				}
			}
		}

		if(!this.children || this.children.length === 0) {
			this.set_placeholder(this.placeholder);
		}	
	},

	add_value: function(data)
	{
		this.set_placeholder(null);

		var element = wabi.createElement("listItemHolder", this);
		element.$item = this.itemCls;
		element.data = data;
	},

	remove_value: function(value)
	{
		if(!this.children) { return; }

		for(var n = 0; n < this.children.length; n++) 
		{
			var child = this.children[n];
			if(child.data === value) {
				this.remove(child);
				return;
			}
		}
	},

	set_placeholder: function(value)
	{
		if(value)
		{
			if(!this.domElement.innerHTML) {
				this.setCls("empty", true);
				this.html(value);
			}
		}
		else
		{
			this.setCls("empty", false);

			if(!this.children || this.children.length === 0) {
				this.html("")
			}
		}
	},

	set_itemCls: function(itemCls)
	{
		if(!itemCls) {
			return "listItem";
		}

		var cls = wabi.element[itemCls];
		if(!cls) {
			console.warn("(wabi.elements.list.set_itemCls) No such element found: " + itemCls);
			return "listItem";
		}
	},

	createFolder: function()
	{
		var element = wabi.createElement("listItem", this);
		element.value = "Folder";
		element.folder = true;
	},

	set select(element)
	{
		if(!this.cache.selectable) { return; }

		element.select = true;
	},

	get select() {
		return this.cache.selected;
	},

	set selectable(value)
	{
		if(this.cache.selectable === value) { return; }
		this.cache.selectable = value;

		if(!value && this.cache.selected) {
			this.cache.selected = false;
		}
	},

	get selectable() {
		return this.cache.selectable;
	},

	//
	cache: null,

	itemCls: "listItem"
});

wabi.element("listItemHolder", 
{
	elements: 
	{
		item: {
			type: null,
			watch_open: "handleItemOpen"
		},
		list: {
			type: "list",
			bind: "content",
			link: "content"
		}
	},

	setup: function() {
		this.attrib("draggable", "true");
		// this.elements.list.cache = this.parent.cache;
	},

	set_item: function(cls)
	{
		this.elements.list.itemCls = cls;
		this.element("item", cls);
	},

	set_content: function(value)
	{
		console.log("set_content", value)
		this.elements.item.$folder = value ? true : false;
		// if(this.itemElement) {
		// 	this.itemElement.folder = value ? true : false;
		// }
	},

	add_content: function(value) 
	{
		console.log("add_content", value)
	},

	updateOpen: function(event) {
		this.elements.list.hidden = !this.itemElement.open;
	},

	handleItemOpen: function(value) {
		this.elements.list.hidden = !value;
	},

	// handle_click: function(event) {

	// 	this.elements.item.select = true;
	// },

	// handle_dblclick: function(event) 
	// {
	// 	if(this.elements.item.$folder) {
	// 		this.elements.item.$open = !this.elements.item.$open;
	// 	}
	// },

	handle_dragstart: function(event) 
	{
		this.setCls("dragging", true);
		// this.cache.dragging = this;
		
		if(this.elements.item.$folder) {
			this.elements.item.$open = false;
		}

		event.domEvent.dataTransfer.effectAllowed = "move";
	},

	handle_dragend: function(event) 
	{
		this.setCls("dragging", false)
	},

	handle_dragenter: function(event) 
	{
		// if(event.element === this) { return; }

		this.setCls("dragover", true);
	},

	handle_dragleave: function(event) 
	{
		// if(event.element === this) { return; }

		this.setCls("dragover", false);
	},

	// handle_dragover: function(event)
	// {
	// 	// if(event.element === this) { return; }

	// 	// var bounds = this.domElement.getBoundingClientRect();
	// 	// // console.log(bounds);
	// 	// // console.log("cursor", event.x, event.y)

	// 	// if((bounds.top + 5) <= event.y) {
	// 	// 	console.log("drag-top");
	// 	// 	return;
	// 	// }
	// 	// else if((bounds.bottom - 5) >= event.y) {
	// 	// 	console.log("drag-bottom")
	// 	// 	return;
	// 	// }

	// 	// event.stop();
	// 	// event.domEvent.dataTransfer.dropEffect = "move";
	// },

	// handle_drop: function(event) 
	// {
	// 	// if(event.element === this) { return; }

	// 	// this.setCls("dragover", false);
	// 	// this.folder = true;

	// 	// var cacheData = this.cache.dragging.data;
	// 	// this.data.push("content", cacheData);

	// 	// event.stop();
	// },	

	// handle_mouseenter: function(event) {
	// 	event.stop();
	// 	event.domEvent.stopPropagation()
	// 	console.log("enter", this.elements.item.$value);
	// 	this.elements.item.setCls("hover", true)
	// },

	// handle_mouseleave: function(event) {
	// 	event.stop();
	// 	event.domEvent.stopPropagation()
	// 	console.log("leave", this.elements.item.$value)
	// 	this.elements.item.setCls("hover", false);
	// },

	//
	tag: "holder",
	itemElement: null,
	draggable: false,
	region: true
});

wabi.element("listItem",
{
	elements: 
	{
		folder: null,
		word: {
			type: "text",
			link: "value",
			bind: "value"
		}
	},

	setup: function() 
	{
		this.attrib("tabindex", "0");

		this.on("click", "*", function() {
			this.select = true;
		}, this);

		this.editable = false;
	},

	cleanup: function() 
	{
		if(this.cache.selected === this) {
			this.cache.selected = null;
		}
	},

	set select(value)
	{
		if(value)
		{
			if(this.cache.selected) {
				this.cache.selected.select = false;
			}

			this.cache.selected = this;
		}
		else
		{
			if(this.cache.selected !== this) { 
				this.cache.selected = null;
			}
		}

		this.setCls("selected", value);
	},

	get select() {
		return (this === this.cache.selected);
	},

	set_folder: function(value) 
	{
		this.slot("folder", value ? "caret" : null);

		if(value) {
			this.open = false;
		}
	},

	handle_click: function(event) {
		this.select = true;
	},

	handle_dblclick: function(event)
	{
		if(this.folder) {
			this.open = !this.open;
		}
	},

	get cache() {
		return this.parent.parent.cache;
	},

	//
	tag: "item"
});

wabi.element("editableListItem", "listItem",
{
	elements: 
	{
		folder: null,
		word: {
			type: "word",
			link: "value",
			bind: "value"
		}
	}
});

"use strict";

wabi.element("loader", 
{
	setup: function() {
		this.hidden = true;
	}
});

"use strict";

wabi.element("menubar",
{
	elements: 
	{
		left: {
			type: "content",
			link: "value"
		},
		center: {
			type: "content",
			link: "center"
		},
		right: {
			type: "content",
			link: "right"
		}
	},

	setup: function()
	{
		this.elements.left.setCls("left", true);
		this.elements.center.setCls("center", true);
		this.elements.right.setCls("right", true);
	}
});

"use strict";

wabi.element("number", 
{
	state: {
		value: 0,
		min: Number.MIN_SAFE_INTEGER,
		max: Number.MAX_SAFE_INTEGER			
	},

	prepare: function() {
		this.attrib("type", "text");
	},

	set_value: function(value)
	{
		if(isNaN(value)) {
			// value = "0";
			//value = 0;
			console.log("num", value)
		}
		else
		{
			if(value < this.min) {
				value = this.min;
			}
			if(value > this.max) {
				value = this.max;
			}
		}

		this.domElement.value = value + "";

		return value;
	},

	set_min: function(value) {
		this.$value = this.$value;
	},

	set_max: function(value) {
		this.$value = this.$value;
	},

	handle_keydown: function(event)
	{
		var domEvent = event.domEvent;

		if(domEvent.ctrlKey) { return; }

		var keyCode = domEvent.keyCode;

		// If arrows:
		if(keyCode >= 37 && keyCode <= 40) {
			return;
		}

		// If numpad:
		if(keyCode >= 96 && keyCode <= 105) {
			keyCode -= 48;
		}

		var value = domEvent.target.value;

		switch(keyCode)
		{
			case 8: // Backspace
			case 46: // Delete
				return;

			case 27: // Esc
				domEvent.target.value = this._value;
				return;

			case 187: // +
			case 189: // -
			{
				if(domEvent.target.selectionStart !== 0 && value.length !== 0) {
					domEvent.preventDefault();
				}
			} return;

			case 190: // "."
			{
				var firstIndex = value.indexOf(".");
				if(firstIndex !== -1) {
					domEvent.preventDefault();
				}
			} return;
		}

		var key = String.fromCharCode(keyCode)
		if(isNaN(key)) {
			domEvent.preventDefault();
		}
	},

	handle_change: function(event) {
		this.$value = parseFloat(this.domElement.value);
	},

	//
	tag: "input"
});

"use strict";

wabi.element("panel", 
{
	state: {
		header: "Panel"
	},

	elements: 
	{
		header: { 
			type: "header",
			link: "header"
		},
		content: {
			type: "content",
			link: "value"
		}
	},

	set width(width) 
	{
		this.style("width", width + "px");
	},

	get width() {
		return this._width;
	},

	set height(height) 
	{
		this.style("min-height", height + "px");		
	},

	get height() {
		return this._height;
	},

	//
	_width: 0,
	_height: 0
});

"use strict";

wabi.element("row", 
{
	set_value: function(value) 
	{
		this.removeAll();
		
		if(!value) { return; }

		for(var n = 0; n < value.length; n++)
		{
			var elementCfg = value[n];

			var element = wabi.createElement(elementCfg.type, this);
			if(!element) {
				continue;
			}

			for(var key in elementCfg) 
			{
				if(key === "type") { continue; }

				element[key] = elementCfg[key];
			}
		}	
	}
});

"use strict";

wabi.element("span", {});

"use strict";

wabi.element("tag",
{
	set_value: function(value)
	{
		console.log("tag", value)

		if(!value) {
			this.html("");
		}
		else {
			this.html(value);
		}
	}
});

"use strict";

wabi.element("template", 
{
	process_value: function(value)
	{
		this.removeAll();

		var elements = wabi.element;
		for(var n = 0; n < value.length; n++)
		{
			var elementCfg = value[n];
			if(!elementCfg.type) {
				console.warn("(editor.element.template) Undefined element type");
				continue;
			}

			var elementCls = elements[elementCfg.type];
			if(!elementCls) {
				console.warn("(editor.element.template) Undefined element type: " + elementCfg.type);
				continue;
			}

			var element = new elementCls(this);
			element.cfg = elementCfg;
		}
	}
});

"use strict";

wabi.element("text", 
{
	state: {
		value: ""
	},

	set_value: function(value) {
		this.html(value);
	}
});

"use strict";

wabi.element("upload",
{
	prepare: function()
	{
		this.attrib("type", "file");
		this.attrib("multiple", "");
		this.attrib("directory", "");
	},

	set_value: function(value) {
		this.domElement.value = value;
	},

	open: function() {
		this.domElement.click();
	},

	get files() {
		return this.domElement.files;
	},

	//
	tag: "input"
});

"use strict";

wabi.element("word", 
{
	state: {
		value: ""
	},

	prepare: function()
	{
		this.attrib("spellcheck", "false");
		this.attrib("tabindex", "0");
	},

	set_value: function(value)
	{
		this.html(value);

		if(this.$value && value && value !== this.$value) 
		{
			this.setCls("highlight", true);
			
			var self = this;
			setTimeout(function() {
				self.setCls("highlight", false);
			}, 600);
		}			
	},

	set editable(value)
	{
		if(this._editable === value) { return; }
		this._editable = value;

		if(!value) {
			this.domElement.contentEditable = "false";
		}
	},

	get editable() {
		return this._editable;
	},

	handle_dblclick: function(event)
	{
		if(this.editable) {
			this.domElement.contentEditable = "true";
			this.domElement.focus();
			meta.selectElementContents(this.domElement);
		}
	},

	handle_blur: function(event)
	{
		var newValue = this.html();
		if(newValue) {
			this.$value = newValue;
		}
		else {
			this.html(this.$value);
		}

		if(this.editable) {
			this.domElement.contentEditable = "false";
		}
	},

	handle_keydown: function(event)
	{
		var keyCode = event.domEvent.keyCode;

		// only 0..9, a..z, A..Z, -, _, ., space
		if((keyCode > 47 && keyCode < 58) || 
		   (keyCode > 64 && keyCode < 91) || 
		   (keyCode > 96 && keyCode < 123) || keyCode === 95 || keyCode === 189 || keyCode === 190 || keyCode === 32)
		{
			return;
		}

		// Backspace
		if(keyCode === 8) {
			return;
		}
		// Arrow keys
		else if(keyCode >= 37 && keyCode <= 40) {
			return;
		}
		// Esc
		else if(keyCode === 27) {
			this.domElement.blur();
		}
		// Enter
		else if(keyCode === 13) {
			this.domElement.blur();
			this.domElement.scrollIntoView(true);
		}

		event.domEvent.preventDefault();
	},

	handle_change: function(event) {
		this.$value = this.html();
	},

	//
	_editable: true
});

"use strict";

wabi.element("wrapped", 
{
	create: function(params) 
	{
		if(typeof(params) === "string") {
			this.tag = params;
		}
		else if(params instanceof Element) {
			this.tag = params.tagName;
			this.domElement = params;
		}
	}
});

"use strict";

wabi.event = function(name, element, domEvent)
{
	this.name = name;
	this.element = element;

	if(domEvent) 
	{
		this.domEvent = domEvent;

		if(domEvent.clientX) 
		{
			this.x = domEvent.clientX;
			this.y = domEvent.clientY;
			this.updateElementOffset(event);
		}
		else {
			this.x = 0;
			this.y = 0;
		}
	}		
};

wabi.event.prototype = 
{
	updateElementOffset: function()
	{
		var offsetLeft = 0;
		var offsetTop = 0;

		if(this.element)
		{
			var domElement = this.element.domElement;
			if(domElement.offsetParent)
			{
				do 
				{
					if(domElement.tagName === "IFRAME") {
						offsetLeft += domElement.offsetLeft;
						offsetTop += domElement.offsetTop;
					}

				} while(domElement = domElement.offsetParent);
			}
		}

		if(this.element && this.element.domElement.tagName === "IFRAME") 
		{
			var rect = this.element.domElement.getBoundingClientRect();
			this.x += rect.left;
			this.y += rect.top;
		}
	},	

	stop: function()
	{
		this.domEvent.preventDefault();
		this.domEvent.stopPropagation();		
	},

	get target() {
		return this.domEvent.target.holder;
	},

	//
	domEvent: null,
	x: 0,
	y: 0
};

"use strict";

var meta = {};

"use strict";

meta.ajax = function(params)
{
	var data = meta.serialize(params.data);
	var xhr = new XMLHttpRequest();

	if(params.dataType === "html") {
		params.responseType = "document";
	}
	else if(params.dataType === "script" || params.dataType === "json") {
		params.responseType = "text";
	}
	else if(params.dataType === void(0)) {
		params.responseType = "GET";
		xhr.overrideMimeType("text/plain");
	}
	else {
		params.responseType = params.dataType;
	}

	if(params.type === void(0)) {
		params.type = "GET";
	}	

	xhr.open(params.type, params.url, true);
	xhr.onload = function()
	{
		if(xhr.readyState === 4 && xhr.status === 200)
		{
			if(params.success !== void(0))
			{
				if(params.responseType === "document") {
					params.success(xhr.responseXML);
				}
				else if(params.dataType === "script") {
					params.success(eval(xhr.responseText));
				}
				else if(params.dataType === "json") {
					params.success(JSON.parse(xhr.responseText));
				}
				else {
					params.success(xhr.responseText);
				}
			}
		}
		else
		{
			if(params.error !== void(0)) {
				params.error();
			}
		}
	};

	xhr.send(data);

	return xhr;
};

"use strict";

(function(scope) 
{
	if(!scope.meta) {
		scope.meta = {};
	}

	var initializing = false;
	var fnTest = /\b_super\b/;
	var holders = {};

	meta.class = function(clsName, extendName, prop, cb) 
	{
		if(!initializing) {
			meta.class._construct(clsName, extendName, prop, cb);
		}
	};

	meta.class._construct = function(clsName, extendName, prop, cb) 
	{
		if(!clsName) {
			console.error("(meta.class) Invalid class name");
			return;
		}

		if(!prop) {
			prop = extendName;
			extendName = null; 
		}
		if(!prop) {
			prop = {};	
		}

		var extend = null;

		if(extendName)
		{
			var prevScope = null;
			var extendScope = window;
			var extendScopeBuffer = extendName.split(".");
			var num = extendScopeBuffer.length - 1;
			
			for(var n = 0; n < num; n++) 
			{
				prevScope = extendScope;
				extendScope = extendScope[extendScopeBuffer[n]];
				if(!extendScope) {
					extendScope = {};
					prevScope[extendScopeBuffer[n]] = extendScope;				
				}
			}	

			var name = extendScopeBuffer[num];
			extend = extendScope[name];
			if(!extend) 
			{
				var holder = holders[extendName];
				if(!holder) {
					holder = new ExtendHolder();
					holders[extendName] = holder;
				}

				holder.classes.push(new ExtendItem(clsName, prop, cb));			
				return;
			}			
		}		

		Extend(clsName, extend, prop, cb);  	
	};

	function Extend(clsName, extend, prop, cb) 
	{
		var prevScope = null;
		var scope = window;
		var scopeBuffer = clsName.split(".");
		var num = scopeBuffer.length - 1;
		var name = scopeBuffer[num];

		for(var n = 0; n < num; n++) 
		{
			prevScope = scope;
			scope = scope[scopeBuffer[n]];
			if(!scope) {
				scope = {};
				prevScope[scopeBuffer[n]] = scope;
			}
		}

		var extendHolder = holders[clsName];
		var prevCls = scope[name];
		var cls = function Class(a, b, c, d, e, f) 
		{
			if(!initializing) 
			{
				if(this.init) { 
					this.init(a, b, c, d, e, f); 
				}
			}
		};		

		var proto = null;
		var extendProto = null;

		if(extend) {
			initializing = true;
			proto = new extend();
			extendProto = proto.__proto__;
			initializing = false;
		}
		else {
			initializing = true;
			proto = new meta.class();
			initializing = false;
		}			

		for(var key in prop)
		{
			var p = Object.getOwnPropertyDescriptor(prop, key);
			if(p.get || p.set) {
				Object.defineProperty(proto, key, p);
				continue;
			}

			if(extend)
			{
				if(typeof(prop[key]) == "function" 
					&& typeof extendProto[key] == "function" 
					&& fnTest.test(prop[key]))
				{
					proto[key] = (function(key, fn)
					{
						return function(a, b, c, d, e, f)
						{
							var tmp = this._super;
							this._super = extendProto[key];
							this._fn = fn;
							var ret = this._fn(a, b, c, d, e, f);

							this._super = tmp;

							return ret;
						};
					})(key, prop[key]);
					continue;
				}
			}

			proto[key] = prop[key];
		}

		cls.prototype = proto;
		cls.prototype.__cls__ = cls;
		cls.prototype.__name__ = clsName;
		cls.prototype.__lastName__ = name;
		cls.prototype.constructor = proto.init || null;
		scope[name] = cls;

		if(prevCls) {
			for(var key in prevCls) {
				cls[key] = prevCls[key];
			}
		}

		if(extendHolder) {
			var extendItem = null;
			var classes = extendHolder.classes;
			num = classes.length;
			for(n = 0; n < num; n++) {
				extendItem = classes[n];
				Extend(extendItem.name, cls, extendItem.prop, extendItem.cb);
			}

			delete holders[clsName];		
		}

		if(cb) {
			cb(cls, clsName);
		}
	};

	function ExtendHolder() {
		this.classes = [];
	};

	function ExtendItem(name, prop, cb) {
		this.name = name;
		this.prop = prop;
		this.cb = cb;
	};

	meta.classLoaded = function()
	{
		var i = 0;
		var holder = null;
		var classes = null;
		var numClasses = 0;

		for(var key in holders) {
			holder = holders[key];
			console.error("Undefined class: " + key);
			classes = holder.classes;
			numClasses = classes.length;
			for(i = 0; i < numClasses; i++) {
				console.error("Undefined class: " + classes[i].name);
			}
		}

		holder = {};
	};	
})(typeof(window) !== void(0) ? window : global);

meta.enumNames = function(baseName, mask, min, max)
{
	var names = new Array(max - min);

	var maskLength = mask.length;
	var numbers;

	for(var n = min; n <= max; n++) {
		numbers = Math.floor(n / 10);
		names[n] = baseName + mask.substr(0, maskLength - numbers - 1) + n;
	}

	return names;
};

meta.getNameFromPath = function(path)
{
	var wildcardIndex = path.lastIndexOf(".");
	var slashIndex = path.lastIndexOf("/");

	// If path does not have a wildcard:
	if(wildcardIndex < 0 || (path.length - wildcardIndex) > 5) { 
		return path.slice(slashIndex + 1);
	}

	return path.slice(slashIndex + 1, wildcardIndex);
};

meta.randomItem = function(array) {
	return array[meta.random.number(0, array.length - 1)];
};

meta.onDomLoad = function(func)
{
	if((document.readyState === "interactive" || document.readyState === "complete")) {
		func();
		return;
	}

	var cbFunc = function(event) {
		func();
		window.removeEventListener("DOMContentLoaded", cbFunc);
	};

	window.addEventListener("DOMContentLoaded", cbFunc);
};

/**
 * Get enum key as string.
 * @param buffer {Object} Enum object where key is located.
 * @param value {*} Value of the key which needs to be converted.
 * @returns {string} Converted enum to string.
 */
meta.enumToString = function(buffer, value)
{
	if(buffer === void(0)) {
		return "unknown";
	}

	for(var enumKey in buffer)
	{
		if(buffer[enumKey] === value) {
			return enumKey;
		}
	}

	return "unknown";
};

/**
 * Convert hex string to object with RGB values.
 * @param hex {String} Hex to convert.
 * @return {{r: Number, g: Number, b: Number}} Object with rgb values.
 */
meta.hexToRgb = function(hex)
{
	if(hex.length < 6) {
		hex += hex.substr(1, 4);
	}

	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return {
		r: parseInt(result[1], 16),
		g: parseInt(result[2], 16),
		b: parseInt(result[3], 16)
	}
};

/**
 * Check if string is url.
 * @param str {string} String to check.
 * @returns {boolean} <b>true</b> if is url.
 */
meta.isUrl = function(str)
{
	if(str.indexOf("http://") !== -1 || str.indexOf("https://") !== -1) {
		return true;
	}

	return false;
};

/**
 * Change to upper case first character of the string.
 * @param str {String} String to perform action on.
 * @returns {String}
 */
meta.toUpperFirstChar = function(str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
};


meta.serialize = function(obj)
{
	var str = [];
	for(var key in obj) {
		str.push(encodeURIComponent(key) + "=" + encodeURIComponent(obj[key]));
	}

	return str.join("&");
};

meta.removeFromArray = function(item, array) 
{
	var numItems = array.length;
	for(var i = 0; i < numItems; i++) {
		if(item === array[i]) {
			array[i] = array[numItems - 1];
			array.pop();
			break;
		}
	}
};

meta.shuffleArray = function(array) 
{
	var rand = meta.random;
	var length = array.length
	var temp, item;

	while(length) 
	{
		item = rand.number(0, --length);

		temp = array[length];
		array[length] = array[item];
		array[item] = temp;
	}

	return array;
};

meta.shuffleArrayRange = function(array, endRange, startRange) 
{
	var startRange = startRange || 0;
	var rand = meta.random;
	var temp, item;

	while(endRange > startRange) 
	{
		item = rand.number(0, --endRange);

		temp = array[endRange];
		array[endRange] = array[item];
		array[item] = temp;
	}

	return array;
};

meta.mapArray = function(array)
{
	var obj = {};
	var num = array.length;
	for(var n = 0; n < num; n++) {
		obj[array[n]] = n;
	}

	return obj;
};

meta.rotateArray = function(array)
{
	var tmp = array[0];
	var numItems = array.length - 1;
	for(var i = 0; i < numItems; i++) {
		array[i] = array[i + 1];
	}
	array[numItems] = tmp;
};

meta.nextPowerOfTwo = function(value)
{
    value--;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value++;

    return value;	
};

meta.toHex = function(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
};

meta.rgbToHex = function(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
};

function isSpace(c) {
	return (c === " " || c === "\t" || c === "\r" || c === "\n");
};

function isNewline(c) {
	return (c === "\r" || c === "\n");
};

function isDigit(c) {
	return (c >= "0" && c <= "9") || (c === ".");
};

function isAlpha(c) 
{
	return (c >= "a" && c <= "z") ||
		   (c >= "A" && c <= "Z") ||
		   (c == "_" && c <= "$");
};

function isAlphaNum(c) 
{
	return (c >= "a" && c <= "z") ||
		   (c >= "A" && c <= "Z") ||
		   (c >= "0" && c <= "9") ||
		   c === "_" || c === "$";
};

function isBinOp(c) 
{
	return (c === "=" || c === "!" || c === "<" || c === ">" || 
			c === "+" || c === "-" || c === "*" || c === "/" ||
			c === "&" || c === "~" || c === "|" || c === "%");
};

function getClsFromPath(path)
{
	var cls = null;
	var scope = window;
	var num = path.length;
	for(var i = 0; i < num; i++) {
		scope = scope[path[i]];
		if(!scope) {
			return null;
		}
	}

	return cls;
};

meta.decodeBinaryBase64 = function(content)
{
	var decodedData = atob(content);
	var size = decodedData.length;
	var data = new Array(size / 4);

	for(var n = 0, i = 0; n < size; n += 4, i++)
	{
		data[i] = decodedData.charCodeAt(n) | 
				  decodedData.charCodeAt(n + 1) << 8 |
				  decodedData.charCodeAt(n + 2) << 16 |
				  decodedData.charCodeAt(n + 3) << 24;
	}

	return data;
}

/**
 * Object that holds information about channel.
 * @property name {String} Name of the channel.
 * @property subs {Array} Array with subsribers.
 * @property numSubs {Number} Total count of subscribers.
 */
meta.Channel = function(name)
{
	this.name = name;
	this.subs = [];
	this.numSubs = 0;

	this._emitting = false;
	this._subsToRemove = null;
};

meta.Channel.prototype =
{
	/**
	 * Emit an event to all subscribers.
	 * @param data {*} Data that comes with event.
	 * @param event {*} Type of event.
	 */
	emit: function(data, event)
	{
		this._emitting = true;

		var sub;
		for(var i = 0; i < this.numSubs; i++) {
			sub = this.subs[i];
			sub.func.call(sub.owner, data, event);
		}

		this._emitting = false;

		// Remove subs from this channel that offd while emited.
		if(this._subsToRemove) 
		{
			var numToRemove = this._subsToRemove.length;
			for(var n = 0; n < numToRemove; n++) {
				this.remove(this._subsToRemove[n]);
			}

			this._subsToRemove = null;
		}
	},

	/**
	 * Subscribe to the channel.
	 * @param owner {Object} Pointer to the owner object.
	 * @param func {Function} Callback function.
	 */
	add: function(func, owner, priority)
	{
		priority = priority || 0;

		if(!func) {
			console.warn("(meta.Channel.subscribe) No valid callback function passed.");
			return;			
		}

		for(var i = 0; i < this.numSubs; i++)
		{
			if(this.subs[i].owner === owner) {
				console.warn("(meta.Channel.subscribe) Already subscribed to channel: " + this.name);
				return;
			}
		}

		var newSub = new meta.Subscriber(owner, func, priority);
		this.subs.push(newSub);
		this.numSubs++;

		if(priority) {
			this._havePriority = true;
			this.subs.sort(this._sortFunc);
		}
		else if(this._havePriority) {
			this.subs.sort(this._sortFunc);
		}
	},

	/**
	 * Unsubscribe from the channel.
	 * @param owner {Object} Pointer to the owner object.
	 */
	remove: function(owner)
	{
		if(owner === null || owner === void(0)) {
			meta.channels[this.name] = null;
		}
		else
		{
			if(this._emitting) 
			{
				if(!this._subsToRemove) {
					this._subsToRemove = [];
				}
				this._subsToRemove.push(owner);
				return;
			}
	
			var sub;
			for(var i = 0; i < this.numSubs; i++)
			{
				sub = this.subs[i];
				if(sub.owner === owner) {
					this.subs[i] = this.subs[this.numSubs - 1];
					this.subs.pop();
					this.numSubs--;
					break;
				}
			}
	
			if(this._havePriority) {
				this.subs.sort(this._sortFunc);
			}
		}
	},

	removeAll: function() {
		this.subs = [];
		this.numSubs = 0;
	},

	_sortFunc: function(a, b) {
		return (a.priority > b.priority) ? -1 : 1
	},

	//
	_havePriority: false
};

meta.Subscriber = function(owner, func, priority) {
	this.owner = owner;
	this.func = func;
	this.priority = priority;
};

/**
 * Create or get channel from the scope.
 * @param name {String} Name of the channel.
 * @return {meta.Channel} Created channel.
 * @memberof! <global>
 */
meta.createChannel = function(name)
{
	if(!name) {
		console.warn("(meta.createChannel) No name was specified!");
		return null;
	}

	var channel = meta.channels[name];
	if(!channel) {
		channel = new meta.Channel(name);
		meta.channels[name] = channel;
	}

	return channel;
};

/**
 * Release channel.
 * @param name
 * @memberof! <global>
 */
meta.releaseChannel = function(name)
{
	if(!name) {
		console.warn("(meta.releaseChannel) No name was specified!");
		return;
	}

	if(meta.channels[name]) {
		meta.channels[name] = null;
	}
};

/**
 * Subscribe to the channel.
 * @param owner {Object} Pointer of the owner object.
 * @param channel {meta.Channel|String|Array} Name, object or array of the channels to subscribe to.
 * @param func {Function} Callback function that will be called when emit arrives.
 * @memberof! <global>
 */
meta.subscribe = function(channel, func, owner, priority)
{
	if(typeof(owner) !== "object") {
		console.warn("(meta.subscribe) No owner passed.");
		return;
	}
	if(!func) {
		console.warn("(meta.subscribe) No callback function passed.");
		return;		
	}

	if(typeof(channel) === "string")
	{
		var srcChannel = meta.channels[channel];
		if(!srcChannel)
		{
			channel = meta.createChannel(channel);
			if(!channel) {
				return;
			}
		}
		else {
			channel = srcChannel;
		}
	}
	else if(Object.prototype.toString.call(channel) === "[object Array]")
	{
		var numChannels = channel.length;
		for(var i = 0; i < numChannels; i++) {
			meta.subscribe(channel[i], func, owner, priority);
		}
		return;
	}
	else {
		console.warn("(meta.subscribe) Wrong type for channel object: " + typeof(channel));
		return;
	}

	channel.add(func, owner, priority);
};

/**
 * Unsubscribe from the channel.
 * @param owner {Object} Pointer of the owner object.
 * @param channel {meta.Channel|String|Array} Name, object or array of the channels to unsubscribe from.
 * @memberof! <global>
 */
meta.unsubscribe = function(channel, owner)
{
	if(typeof(channel) === "string")
	{
		channel = meta.channels[channel];
		if(!channel) {
			console.warn("(meta.unsubscribe) No name was specified!");
			return;
		}
	}
	else if(Object.prototype.toString.call(channel) === "[object Array]")
	{
		var numChannels = channel.length;
		for(var i = 0; i < numChannels; i++) {
			meta.unsubscribe(channel[i], owner);
		}
		return;
	}
	else {
		console.warn("(meta.unsubscribe) Wrong type for channel object.");
		return;
	}

	channel.remove(owner);
};

/**
 * Emit an event to all subscribers.
 * @param channel {String} Name of the channel.
 * @param data {*} Data that comes with event.
 * @param event {*} Type of event.
 */
meta.emit = function(channel, data, event)
{
	if(typeof(channel) === "string")
	{
		channel = meta.channels[channel];
		if(!channel) {
			console.warn("(meta.emit) No name was specified!");
			return;
		}
	}

	channel.emit(data, event);
};

meta.channels = [];

/**
 * @description Manages client feature support and adds missing functionality.
 * @constructor
 * @property vendors {Array} Buffer with vendors to perform check on.
 * @property support {Object} Dictionary of supported features.
 * @property mobile {Boolean} Flag if it's mobile device.
 * @memberof! <global>
 */
meta.Device = function()
{
	this.name = "unknown";
	this.version = "0";
	this.versionBuffer = null;

	this.vendors = [ "", "webkit", "moz", "ms", "o" ];
	this.vendor = "";
	this.support = {};

	this.audioFormats = [];

	this.mobile = false;
	this.isPortrait = false;
	this.audioAPI = false;

	this.hidden = null;
	this.visibilityChange = null;

	this.fullScreenRequest = null;
	this.fullScreenExit = null;
	this.fullScreenOnChange = null;
	this.fullscreen = false;

	this.load();
};

meta.Device.prototype =
{
	/**
	 * @description Load all support related stuff.
	 */
	load: function()
	{
		this.checkBrowser();

		this.mobile = this.isMobileAgent();

		this.checkConsoleCSS();
		this.checkFileAPI();

		this.support.onloadedmetadata = (typeof window.onloadedmetadata === "object");
		this.support.onkeyup = (typeof window.onkeyup === "object");
		this.support.onkeydown = (typeof window.onkeydown === "object");

		this.support.canvas = this.isCanvasSupport();
		this.support.webgl = this.isWebGLSupport();

		this.modernize();
	},

	/**
	 * Check browser name and version.
	 */
	checkBrowser: function()
	{
		var regexps = {
			"Chrome": [ /Chrome\/(\S+)/ ],
			"Firefox": [ /Firefox\/(\S+)/ ],
			"MSIE": [ /MSIE (\S+);/ ],
			"Opera": [
				/OPR\/(\S+)/,
				/Opera\/.*?Version\/(\S+)/,     /* Opera 10 */
				/Opera\/(\S+)/                  /* Opera 9 and older */
			],
			"Safari": [ /Version\/(\S+).*?Safari\// ]
		};

		var userAgent = navigator.userAgent;
		var name, currRegexp, match;
		var numElements = 2;

		for(name in regexps)
		{
			while(currRegexp = regexps[name].shift())
			{
				if(match = userAgent.match(currRegexp))
				{
					this.version = (match[1].match(new RegExp('[^.]+(?:\.[^.]+){0,' + --numElements + '}')))[0];
					this.name = name;

					this.versionBuffer = this.version.split(".");
					var versionBufferLength = this.versionBuffer.length;
					for(var i = 0; i < versionBufferLength; i++) {
						this.versionBuffer[i] = parseInt(this.versionBuffer[i]);
					}

					break;
				}
			}
		}

		if(this.versionBuffer === null || this.name === "unknown") {
			console.warn("(meta.Device.checkBrowser) Could not detect browser.");
		}
		else {
			if(this.name === "Chrome" || this.name === "Safari" || this.name === "Opera") {
				this.vendor = "webkit";
			}
			else if(this.name === "Firefox") {
				this.vendor = "moz";
			}
			else if(this.name === "MSIE") {
				this.vendor = "ms";
			}
		}				
	},

	checkConsoleCSS: function() 
	{
		if(!this.mobile && (this.name === "Chrome" || this.name === "Opera")) {
			this.support.consoleCSS = true;
		}
		else {
			this.support.consoleCSS = false;
		}		
	},

	checkFileAPI: function() 
	{
		if(window.File && window.FileReader && window.FileList && window.Blob) {
			this.support.fileAPI = true;
		}
		else {
			this.support.fileAPI = false;
		}
	},

	/**
	 * @description Add support for missing functionality.
	 */
	modernize: function()
	{
		if(!Number.MAX_SAFE_INTEGER) {
			Number.MAX_SAFE_INTEGER = 9007199254740991;
		}

		this.supportConsole();
		this.supportPageVisibility();
		this.supportFullScreen();
		this.supportRequestAnimFrame();
		this.supportPerformanceNow();
		this.supportAudioFormats();
		this.supportAudioAPI();
		this.supportFileSystemAPI();
	},


	/**
	 * Test if agent is on mobile device.
	 * @returns {boolean}
	 */
	isMobileAgent: function() {
		return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
	},

	/**
	 * @description Check if client supports Canvas rendering context.
	 * @return {boolean}
	 */
	isCanvasSupport: function() {
		return !!window.CanvasRenderingContext2D;
	},

	/**
	 * @description Check if client supports WebGL rendering context.
	 * @return {boolean}
	 */
	isWebGLSupport: function()
	{
		var canvas = document.createElement("canvas");
		var context = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

		return !!context;
	},


	/**
	 * If console is not supported replace it with empty functions.
	 */
	supportConsole: function()
	{
		if(!window.console) {
			window.console = {};
			window.console.log = meta.emptyFuncParam;
			window.console.warn = meta.emptyFuncParam;
			window.console.error = meta.emptyFuncParam;
		}
	},

	/**
	 * Check if Page Visibility API is available and which prefix to use.
	 */
	supportPageVisibility: function()
	{
		if(document.hidden !== void(0)) {
			this.hidden = "hidden";
			this.visibilityChange = "visibilitychange";
		}
		else if(document.hidden !== void(0)) {
			this.hidden = "webkitHidden";
			this.visibilityChange = "webkitvisibilitychange";
		}
		else if(document.hidden !== void(0)) {
			this.hidden = "mozhidden";
			this.visibilityChange = "mozvisibilitychange";
		}
		else if(document.hidden !== void(0)) {
			this.hidden = "mshidden";
			this.visibilityChange = "msvisibilitychange";
		}
	},

	/**
	 * Check if FullScreen API is available and which prefix to use.
	 */
	supportFullScreen: function()
	{
		this._fullScreenRequest();
		this._fullScreenExit();
		this._fullScreenOnChange();

		this.support.fullScreen = document.fullscreenEnabled || document.mozFullScreenEnabled ||
			document.webkitFullscreenEnabled || document.msFullscreenEnabled;
	},

	_fullScreenRequest: function()
	{
		var element = document.documentElement;
		if(element.requestFullscreen !== void(0)) {
			this.fullScreenRequest = "requestFullscreen";
		}
		else if(element.webkitRequestFullscreen !== void(0)) {
			this.fullScreenRequest = "webkitRequestFullscreen";
		}
		else if(element.mozRequestFullScreen !== void(0)) {
			this.fullScreenRequest = "mozRequestFullScreen";
		}
		else if(element.msRequestFullscreen !== void(0)) {
			this.fullScreenRequest = "msRequestFullscreen";
		}
	},

	_fullScreenExit: function()
	{
		if(document.exitFullscreen !== void(0)) {
			this.fullScreenExit = "exitFullscreen";
		}
		else if(document.webkitExitFullscreen !== void(0)) {
			this.fullScreenExit = "webkitExitFullscreen";
		}
		else if(document.mozCancelFullScreen !== void(0)) {
			this.fullScreenExit = "mozCancelFullScreen";
		}
		else if(document.msExitFullscreen !== void(0)) {
			this.fullScreenExit = "msExitFullscreen";
		}
	},

	_fullScreenOnChange: function()
	{
		if(document.onfullscreenchange !== void(0)) {
			this.fullScreenOnChange = "fullscreenchange";
		}
		else if(document.onwebkitfullscreenchange !== void(0)) {
			this.fullScreenOnChange = "webkitfullscreenchange";
		}
		else if(document.onmozfullscreenchange !== void(0)) {
			this.fullScreenOnChange = "mozfullscreenchange";
		}
		else if(document.onmsfullscreenchange !== void(0)) {
			this.fullScreenOnChange = "msfullscreenchange";
		}
	},

	/**
	 * @description Add support for requestAnimFrame.
	 */
	supportRequestAnimFrame: function()
	{
		if(!window.requestAnimationFrame)
		{
			window.requestAnimationFrame = (function()
			{
				return window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame ||
					window.oRequestAnimationFrame ||
					window.msRequestAnimationFrame ||

					function(callback, element) {
						window.setTimeout( callback, 1000 / 60 );
					};
			})();
		}
	},

	/**
	 * Add support to window.performance.now().
	 */
	supportPerformanceNow: function()
	{
		if(window.performance === void(0)) {
			window.performance = {};
		}

		if(window.performance.now === void(0)) {
			window.performance.now = Date.now;
		}
	},

	/**
	 * Check for supported audio formats.
	 */
	supportAudioFormats: function()
	{
		var audio = document.createElement("audio");
		if(audio.canPlayType("audio/mp4")) {
			this.audioFormats.push("m4a");
		}
		if(audio.canPlayType("audio/ogg")) {
			this.audioFormats.push("ogg");
		}
		if(audio.canPlayType("audio/mpeg")) {
			this.audioFormats.push("mp3");
		}
		if(audio.canPlayType("audio/wav")) {
			this.audioFormats.push("wav");
		}		
	},

	/**
	 * Check for AudioAPI support.
	 */
	supportAudioAPI: function()
	{
		if(!window.AudioContext) {
			window.AudioContext = window.webkitAudioContext || 
				window.mozAudioContext ||
				window.oAudioContext ||
				window.msAudioContext;
		}

		if(window.AudioContext) {
			this.audioAPI = true;
		}
	},

	supportFileSystemAPI: function() 
	{
		if(!window.requestFileSystem) 
		{
			window.requestFileSystem = window.webkitRequestFileSystem || 
				window.mozRequestFileSystem ||
				window.oRequestFileSystem ||
				window.msRequestFileSystem;
		}

		if(window.requestFileSystem) {
			this.support.fileSystemAPI = true;
		}
	}
};

meta.device = new meta.Device();

meta.getElementOffset = function(rootElement)
{
	var offsetLeft = 0;
	var offsetTop = 0;

	var element = rootElement;
	if(element.offsetParent)
	{
		do {
			this.offsetLeft += element.offsetLeft;
			this.offsetTop += element.offsetTop;
		} while(element = element.offsetParent);
	}

	var rect = rootElement.getBoundingClientRect();
	offsetLeft += rect.left;
	offsetTop += rect.top;

	return [ offsetLeft, offsetTop ];
};
"use strict";

var editor = 
{
	prepare: function()
	{
		this.data = new wabi.data({
			public: {},
			private: {}
		});
		this.dataPublic = this.data.get("public");
		this.dataPrivate = this.data.get("private");
		wabi.globalData = this.dataPublic;

		if(window.process && window.process.versions["electron"]) {
			this.electron = true;
		}

		this.connection.on("openProject", this.openProject, this);
		this.connection.on("installPlugins", this.onInstallPlugins, this);

		if(this.electron) {
			this.fs = editor.fileSystemLocal;
		}
		else {
			this.fs = editor.fileSystem;
		}
		this.fs.init();
	},

	handleFsReady: function()
	{
		this.connection.init();
	},

	handleServerReady: function() 
	{
		this.prepareUI();
		this.createPlugins();

		this.info.enable = false;
		this.plugins.login.show();
	},

	onSplashStart: function()
	{
		var plugin;
		for(var key in this.plugins) 
		{
			plugin = this.plugins[key];

			if(plugin.onSplashStart) {
				plugin.onSplashStart();
			}
		}
	},

	onSplashEnd: function()
	{
		var plugin;
		for(var key in this.plugins) 
		{
			plugin = this.plugins[key];
			if(plugin.onSplashEnd) {
				plugin.onSplashEnd();
			}
		}
	},	

	installPlugins: function()
	{
		this.info.value = "Installing plugins";

		var plugins = this.dataPublic.get("plugins");
		var pluginData = {};
		var added = false;

		for(var key in this.plugins) 
		{
			var plugin = this.plugins[key];

			var pluginCfg = plugins.getItem(key);
			if(!pluginCfg) {
				pluginData[key] = {};
				added = true;
			}
		}

		if(!added) {
			this.onStart();
			return;
		}

		editor.connection.emit({
			type: "installPlugins",
			data: pluginData
		});
	},

	onInstallPlugins: function(serverData)
	{
		var data = this.dataPublic.get("plugins");

		var plugin;
		var pluginData = serverData.data;
		for(var key in pluginData) 
		{
			data.performSetKey(key, pluginData[key]);

			plugin = this.plugins[key];
			if(plugin.install) {
				plugin.install();
			}
		}

		this.onStart();
	},

	onStart: function()
	{
		var plugin;
		
		for(var key in this.plugins) 
		{
			plugin = this.plugins[key];
			if(plugin.onPrepare) {
				plugin.onPrepare();
			}
		}

		for(var key in this.plugins) 
		{
			plugin = this.plugins[key];
			if(plugin.onStart) {
				plugin.onStart();
			}
		}

		this.info.enable = false;

		setInterval(this.update.bind(this), 2000);
	},

	prepareUI: function()
	{
		this.wrapperElement = wabi.createElement("wrapped", document.body, "wrapper");
		this.overlayElement = wabi.createElement("wrapped", document.body, "overlay");

		this.info = wabi.createElement("text", this.overlayElement);
		this.info.value = "Initializing";
	},	

	createPlugins: function()
	{
		this.plugins = {};

		this.loadPlugin("resources");
		this.loadPlugin("contextmenu");
		this.loadPlugin("login");
		this.loadPlugin("menubar");
		this.loadPlugin("projects");
	},

	loadPlugin: function(name)
	{
		if(this.plugins[name]) {
			console.error("(editor.installPlugin) There is already installed plugin - '" + name + "'");
			return;
		}

		var pluginCls = this.plugin[name];
		if(!pluginCls) {
			console.error("(editor.installPlugin) No such plugin registered - '" + name + "'");
			return;
		}

		var plugin = new pluginCls();
		this.plugins[name] = plugin;
	},

	// installPlugins: function()
	// {
	// 	for(var key in Editor.Plugin) 
	// 	{
	// 		if(!this.db.plugins[key]) {
	// 			this.installPlugin(key);
	// 		}
	// 	}
	// },

	// installPlugin: function(name) 
	// {
	// 	if(this.db.plugins[name]) {
	// 		console.warn("(Editor.installPlugin) Plugin is already installed: " + name);
	// 		return;
	// 	}

	// 	var plugin = this.plugins[name];
	// 	if(!plugin) {
	// 		console.warn("(Editor.installPlugin) There is no such plugin available: " + name);
	// 	}

	// 	if(plugin.install) {
	// 		plugin.install(this.db);
	// 	}

	// 	this.db.plugins[name] = {};
	// },

	loadPlugins: function()
	{
		for(var key in this.plugins) {
			this.plugins[key].load(this.db);
		}
	},

	startPlugins: function()
	{
		for(var key in this.plugins) {
			this.plugins[key].start();
		}
	},	

	login: function() 
	{
		this.info.enable = false;
		this.plugins.login.hide();
		this.connection.load();

		this.onSplashStart();
	},

	loadProject: function(data)
	{
		this.onSplashEnd();

		this.info.value = "Loading project";
		this.info.enable = true;

		this.loadPlugin("layout");
		this.loadPlugin("browser");
		this.loadPlugin("inspect");
		this.loadPlugin("meta2d");

		this.connection.emit({
			type: "openProject",
			value: data
		});

		//this.server
		// if(this.electron) 
		// {
		// 	var index = name.lastIndexOf("\\");
		// 	this.projectName = name.slice(index + 1);

		// 	if(name[name.length - 1] !== "\\") {
		// 		name += "\\";
		// 	}
		// 	editor.fileSystem.rootDir = name;
		// 	editor.fileSystem.fullPath = name;
		// }
		// else
		// {
		// 	this.projectName = name;
		// 	this.fileSystem.rootDir = name + "/";
		// 	this.fileSystem.fullPath = "filesystem:http://" + window.location.hostname + "/persistent/" + editor.fileSystem.rootDir;			
		// }

	},

	openProject: function(serverData)
	{
		this.connection.applyData(serverData.data);

		this.dataAssets = this.dataPublic.get("assets");
		this.project = serverData.value;
		this.projectPath = serverData.fullPath;
		this.fs.rootDir = serverData.path;

		document.title = serverData.value + " - " + this.config.titlePrefix;

		this.installPlugins();
	},

	writeFile: function(file, fileResult, callback)
	{
		var name = encodeURIComponent(file.name);
		var wildcardIndex = name.lastIndexOf(".");
		var idName = name.substr(0, wildcardIndex);
		var ext = name.substr(wildcardIndex + 1).toLowerCase();

		var type = this.plugins.resources.getTypeFromExt(ext) || "etc";

		if(this.offline)
		{
			var hash = this.connection.offline.generateHash();
			var filePath = hash + "." + ext;

			var map = this.dataAssets.get(type);
			if(!map) {
				map = this.dataAssets.performSetKey(type, {});
			}

			var info = {
				value: idName,
				ext: ext,
				type: type,
				path: filePath
			};

			if(this.electron)
			{
				this.fs.writeBase64(filePath, fileResult.target.result, function(path) {
					map.add(hash, info);
					if(callback) {
						callback(hash, type);
					}
				});
			}
			else
			{
				var blob = dataURItoBlob(fileResult.target.result, file.type);
				this.fs.writeBlob(filePath, blob, function(path) {
					map.add(hash, info);
					if(callback) {
						callback(hash, type);
					}
				});
			}
		}
		else 
		{

		}	
	},

	deleteFile: function(data)
	{
		data.remove();

		if(this.offline) 
		{
			var filePath = data.id + "." + data.raw.ext;
			this.fs.remove(filePath);
		}
	},

	getContentInfo: function(name)
	{
		var buffer = name.split(".");
		return this.getContentInfoFromBuffer(buffer);
	},

	getContentProps: function(buffer)
	{
		var obj = this.contents;
		var num = buffer.length;
		for(var n = 0; n < num; n++)
		{
			obj = obj[buffer[n]];
			if(!obj) {
				return null;
			}
			
			obj = obj.content;
		}

		return obj.info;
	},

	handleClick: function(domEvent) {
		this.emit("click", domEvent);
	},

	handleContextMenu: function(domEvent) {
		domEvent.preventDefault();
	},

	on: function(event, cb) 
	{
		var buffer = this.eventBuffer[event];
		if(!buffer) {
			this.eventBuffer[event] = [ cb ];
		}
		else {
			buffer.push(cb);
		}
	},

	off: function(event, cb)
	{
		var buffer = this.eventBuffer[event];
		if(buffer) {
			var index = buffer.indexOf(cb);
			buffer = buffer.splice(index, 1);
		}
	},

	emit: function(event, domEvent)
	{
		var buffer = this.eventBuffer[event];
		if(!buffer) { return; }

		for(var n = 0; n < buffer.length; n++) {
			buffer[n](domEvent);
		}
	},

	update: function() {
		this.emit("update", null);
	},

	plugin: function(name, props) 
	{
		function plugin() {
			editor.plugin.basic.call(this);
		};

		plugin.prototype = Object.create(this.plugin.basic.prototype);
		plugin.prototype.constructor = plugin;
		plugin.prototype.$name = name;

		var proto = plugin.prototype;
		var fnTest = /\b_super\b/;

		// Copy properties:
		for(var key in props)
		{
			var p = Object.getOwnPropertyDescriptor(props, key);
			if(p.get || p.set) {
				Object.defineProperty(proto, key, p);
				continue;
			}

			if(typeof(props[key]) == "function"
				&& fnTest.test(props[key]))
			{
				proto[key] = (function(key, fn)
				{
					return function(a, b, c, d, e, f)
					{
						var tmp = this._super;
						this._super = extendProto[key];
						this._fn = fn;
						var ret = this._fn(a, b, c, d, e, f);

						this._super = tmp;

						return ret;
					};
				})(key, props[key]);
				continue;
			}

			proto[key] = props[key];
		}

		this.plugin[name] = plugin;
	},	

	//
	offline: false,
	electron: false,
	
	data: null,
	dataPublic: null,
	dataPrivate: null,
	dataAssets: null,

	eventBuffer: {},

	fileSystem: null,
	inputParser: null,
	resourceMgr: null,
	resources: null,

	project: null,
	projectPath: null,

	plugins: null,

	wrapperElement: null,
	overlayElement: null,
	top: null,
	inner: null,
	bottom: null
};
"use strict";

"require ../editor";

editor.connection =
{
	init: function() 
	{
		this.offline.init();
		this.websocket.init();
	},

	load: function()
	{
		wabi.dataProxy = this.emit.bind(this);
	},

	on: function(type, func, owner)
	{
		var watcher = new wabi.Watcher(owner, func);
		var buffer = this.callbacks[type];
		if(!buffer) {
			buffer = [ watcher ];
			this.callbacks[type] = buffer;
		}
		else {
			buffer.push(watcher);
		}
	},

	off: function(type, func, owner)
	{
		if(typeof(type) === "object")
		{
			owner = type;

			for(var key in this.callbacks)
			{
				var buffer = this.callbacks[key];
				var num = buffer.length;
				for(var n = 0; n < num; n++)
				{
					if(buffer[n].owner !== owner) { continue; }

					buffer[n] = buffer[num - 1];
					buffer.pop();
				}
			}
		}
		else {
			console.log("todo");
		}
	},

	emit: function(data)
	{
		if(editor.offline) {
			this.offline.emit(data);
		}
		else {
			this.websocket.emit(data);
		}
	},

	get: function(id, func, owner)
	{
		var data = editor.data.performSetKey(id, {});
		data.sync();

		if(func) {
			data.watch(func, owner);
		}

		this.emit({
			id: id,
			type: "data",
			action: "get"
		});

		return data;
	},

	handleServerData: function(serverData)
	{
		console.log("recv:", serverData)

		var data = editor.data.get(serverData.id);
		if(!data) { return; }

		switch(serverData.action)
		{
			case "set":
			{
				if(serverData.key === void(0)) {
					data.performSet(serverData.value);
				}
				else {
					data.performSetKey(serverData.key, serverData.value);
				}
			} break;

			case "setkeys":
			{
				data.performSetKeys(serverData.value);
			} break;

			case "add":
			{
				if(serverData.key === void(0)) {
					data.performAdd(serverData.value);
				}
				else {
					data.performAddKey(serverData.key, serverData.value);
				}
			} break;

			case "remove":
			{
				data.performRemove(serverData.key);
			} break;
		}
	},

	applyData: function(data)
	{
		var editorData = editor.dataPublic;

		for(var key in data) {
			editorData.performSetKey(key, data[key]);
		}
	},

	//
	callbacks: {},

	offline: null,
	websocket: null
};

"use strict";

editor.connection.offline =
{
	init: function()
	{
		editor.fs.read("db.json", function(result) 
		{
			if(!result) 
			{
				editor.connection.offline.db = {
					projects: {},
					lastProjectId: 0
				};

				editor.fs.write("db.json", JSON.stringify(editor.connection.offline.db), function() {
					editor.handleServerReady();
				});
			}
			else 
			{
				editor.connection.offline.db = JSON.parse(result);
				editor.handleServerReady();
			}
		});

		editor.fs.createDir("projects");

		editor.on("update", this.handleUpdate, this);
	},

	emit: function(data)
	{
		switch(data.type)
		{
			case "data":
			{
				if(data.id.indexOf("private.projects") > -1) {
					this.processProjects(editor.data.get(data.id), data);
				}
				else 
				{
					if(data.key === "@") {
						data.key = this.generateHash();
					}
					
					editor.connection.handleServerData(data);
					this.saveData();
				}
			} break;

			case "openProject":
				this.openProject(data);
				break;

			case "installPlugins":
				this.installPlugins(data);
				break;
		}
	},

	processProjects: function(editorData, data)
	{
		switch(data.action)
		{
			case "get":
				this.readProjects();
				break;

			case "add": 
				this.createProject(editorData, data);
				break;

			case "remove":
				this.deleteProject(editorData, data);
				break;

			case "set":
				this.renameProject(editorData, data);
				break;
		}
	},

	readProjects: function()
	{
		var data = {};
		var output = {
			id: "private.projects",
			type: "data",
			action: "set",
			value: data
		};

		var projects = this.db.projects;
		for(var key in projects)
		{
			var project = projects[key];
			data[key] = {
				value: project.value
			};
		}

		editor.connection.handleServerData(output);
	},

	processDirs: function(dirs)
	{
		var data = {};
		var output = {
			id: "private.projects",
			type: "data",
			action: "set",
			value: data
		};

		for(var key in dirs)
		{
			var dir = dirs[key];
			data[key] = {
				value: dir.value
			};
		}

		editor.connection.handleServerData(output);
	},

	createProjectData: function()
	{
		var data = {
			name: "Untitled",
			version: editor.config.version,
			plugins: {},
			assets: {},
			lastResourceId: 0
		};

		return data;
	},

	createProject: function(editorData, data)
	{
		var projectId = this.db.lastProjectId++;

		var projectData = this.createProjectData();
		var projectInfo = {
			value: projectData.name,
			path: "projects/" + projectId
		};

		this.db.projects[projectId] = projectInfo;

		editor.fs.write("db.json", JSON.stringify(this.db));

		editor.fs.createDir(projectInfo.path, function(dir) {
			editor.fs.write(projectInfo.path + "/db.json", JSON.stringify(projectData));
		});
		
		editorData.performAddKey(projectId, { value: projectData.name });
	},

	deleteProject: function(editorData, data)
	{
		var projectId = parseInt(data.key.id);
		if(isNaN(projectId)) {
			console.warn("(editor.connection.offline.deleteProject) Invalid project id: " + data.key.id);
			return;
		}

		var project = this.db.projects[projectId];
		if(!project) {
			console.warn("(editor.connection.offline.deleteProject) Project not found with id: " + projectId);
			return;
		}

		var self = this;
		editor.fs.removeDir(project.path, function(dir) {
			if(dir) 
			{
				delete self.db.projects[projectId];
				self.saveDb();

				editorData.performRemove(projectId);
			}
		});
	},

	renameProject: function(editorData, data)
	{
		var project = this.db.projects[editorData.id];
		if(!project) {
			console.warn("(editor.connection.offline.renameProject) Project does not exist: " + editorData.id);
			return;
		}

		project.value = data.value;
		editor.fs.write("db.json", JSON.stringify(this.db));

		var self = this;
		this.readProjectDb(project.path, function(db) {
			db.name = data.value;
			editor.fs.write(project.path + "/db.json", JSON.stringify(db));
		});

		editorData.performSetKey("value", data.value);
	},

	removeProject: function()
	{
		console.log("todo");
	},

	openProject: function(data)
	{
		var projectId = data.value.id;
		var project = this.db.projects[projectId];
		if(!project) {
			console.warn("(editor.connection.offline.openProject) Project does not exist: " + projectId);
			return;
		}

		var projectPath = "projects/" + projectId;
		project.path = projectPath;

		this.readProjectDb(projectPath, function(db) 
		{
			editor.connection.offline.project = project;
			editor.connection.offline.projectDb = db;
			editor.openProject({
				value: project.value,
				data: db,
				id: projectId,
				path: projectPath + "/",
				fullPath: "filesystem:" + editor.config.httpUrl + "/persistent/" + projectPath + "/"
			});
		});
	},

	removeProjects: function()
	{
		editor.fs.remove("db.json");

		editor.fs.removeDir("projects", function(dir) {
			console.log("Offline projects removed");
		});
	},

	installPlugins: function(data)
	{
		editor.fs.write("db.json", JSON.stringify(editor.dataPublic), function() {
			editor.onInstallPlugins(data);
		});
	},

	readProjectDb: function(projectPath, callback)
	{
		if(!callback) {
			console.warn("(editor.connection.offline.readProjectDb) Callback not specified for projectPath: " + projectPath);
			return;
		}

		editor.fs.checkDir(projectPath, function(path) 
		{
			if(!path) {
				console.warn("(editor.connection.offline.readProjectDb) Project directory does not exist: " + projectPath);
				return;
			}

			editor.fs.read(projectPath + "/db.json", function(content) 
			{
				if(!content) 
				{
					var db = editor.connection.offline.createProjectData();

					editor.fs.write(projectPath + "/db.json", JSON.parse(db), function() {
						callback(db);
					});
				}
				else
				{
					var db = JSON.parse(content);
					callback(db);
				}
			});
		});
	},

	saveData: function()
	{
		this.needSave = false;
		editor.fs.write("db.json", JSON.stringify(editor.dataPublic));
	},

	saveDb: function()
	{
		this.needSaveDb = false;
		editor.fs.write("db.json", JSON.stringify(this.db));		
	},

	handleUpdate: function()
	{
		if(this.needSaveDb) {
			this.saveDb();
		}
		if(this.needSave) {
			this.saveData();
		}
	},

	generateHash: function()
	{
		var id = editor.dataPublic.get("lastResourceId");
		editor.dataPublic.performSetKey("lastResourceId", id + 1);
		
		this.needSave = true;
		return btoa(id);
	},

	//
	project: null,
	projectDb: null,
	db: null,
	needSave: false,
	needSaveDb: false
};

"use strict";

editor.connection.websocket =
{
	init: function()
	{
		editor.connection.on("data", this.handleServerData, this);
	},

	connect: function(callback)
	{
		this.$callback = callback;

		this.connection = new WebSocket(editor.config.wsUrl, [ "soap", "xmpp" ]);
		this.connection.onopen = this.handleOpen.bind(this);
		this.connection.onclose = this.handleClose.bind(this);
		this.connection.onerror = this.handleError.bind(this);
		this.connection.onmessage = this.handleMsg.bind(this);
	},

	handleOpen: function()
	{
		this.open = true;

		if(this.$callback) {
			this.$callback();
		}
	},

	handleClose: function(event)
	{
		this.open = false;
		wabi.dataProxy = null;

		var error = this.getError(event);
		if(error) {
			console.error("(editor.connection.websocket.handleClose) " + error);
		}

		var buffer = editor.connection.callbacks.close;
		if(!buffer) {
			return;
		}

		var watcher;
		for(var n = 0; n < buffer.length; n++) {
			watcher = buffer[n];
			watcher.func.call(watcher.owner);
		}
	},

	handleError: function(error, error2)
	{
		
	},

	handleMsg: function(msg)
	{
		var data = JSON.parse(msg.data);
		if(!data.type) {
			return;
		}

		var buffer = editor.connection.callbacks[data.type];
		if(!buffer) {
			return;
		}

		var watcher;
		for(var n = 0; n < buffer.length; n++) {
			watcher = buffer[n];
			watcher.func.call(watcher.owner, data);
		}
	},

	emit: function(data)
	{
		if(!this.open) {
			console.warn("(editor.connection.websocket) Connection is closed");
			return;
		}

		console.log("sent:", data);

		this.connection.send(JSON.stringify(data));
	},

	getError: function(event)
	{
		switch(event.code)
		{
			case 1000:
				return "Normal closure, meaning that the purpose for which the connection was established has been fulfilled.";
       		case 1001:
            	return "An endpoint is \"going away\", such as a server going down or a browser having navigated away from a page.";
            case 1002:
            	return "An endpoint is terminating the connection due to a protocol error";
            case 1003:
            	return "An endpoint is terminating the connection because it has received a type of data it cannot accept (e.g., an endpoint that understands only text data MAY send this if it receives a binary message).";		
			case 1004:
				return "Reserved. The specific meaning might be defined in the future.";
			case 1005:
				return "No status code was actually present.";
			case 1006:
				return "The connection was closed abnormally, e.g., without sending or receiving a Close control frame";
			case 1007:
				return "An endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [http://tools.ietf.org/html/rfc3629] data within a text message).";
			case 1008:
				return "An endpoint is terminating the connection because it has received a message that \"violates its policy\". This reason is given either if there is no other sutible reason, or if there is a need to hide specific details about the policy.";
			case 1009:
				return "An endpoint is terminating the connection because it has received a message that is too big for it to process.";
			case 1010:
				return "An endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, but the server didn't return them in the response message of the WebSocket handshake. <br /> Specifically, the extensions that are needed are: " + event.reason;
			case 1011:
				return "A server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.";
			case 1015:
				return "The connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).";
		}	

		return null;
	},

	//
	connection: null,
	open: false,
	$callback: null
};

editor.connection.websocket.init();

"use strict";

// TODO: queue system for files.

editor.fileSystem =
{
	init: function()
	{
		var self = this;

		navigator.webkitPersistentStorage.requestQuota(64 * 1024 * 1024,
			function(grantedBytes)
			{
				requestFileSystem(PERSISTENT, grantedBytes,
					function(fs) {
						self.handleFileSystemSuccess(fs);
					},
					function(fileError) {
						self.handleError(fileError, "init");
					});
			},
			function(error) {
				console.error("(webkitPersistentStorage) " + error);
			});
	},

	handleFileSystemSuccess: function(fs)
	{
		this.fs = fs.root;
		this.ready = true;
		editor.handleFsReady();
	},

	create: function(filename, cb)
	{
		var self = this;
		var path = this.rootDir + filename;

		this.fs.getFile(path, {
				create: true
			},
			function(fileEntry)
			{
				if(cb) {
					cb();
				}
			},
			function(fileError) {
				self.handleError(fileError, cb, "create", filename);
			});
	},

	read: function(filename, cb)
	{
		var self = this;

		this.fs.getFile(this.rootDir + filename, {},
			function(fileEntry) {
				self.handleReadDone(fileEntry, cb);
			},
			function(fileError) {
				self.handleError(fileError, cb, "read", filename);
			});
	},

	handleReadDone: function(fileEntry, cb)
	{
		var self = this;

		fileEntry.file(
			function(file)
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					if(cb) {
						cb(this.result);
					}
				};

				reader.readAsText(file);
			},
			function(fileError) {
				self.handleError(fileError, cb, "read", fileError.name);
			});
	},

	write: function(filename, content, cb)
	{
		var self = this;

		this.fs.getFile(this.rootDir + filename, { create: true },
			function(fileEntry) {
				self.writeContent(fileEntry, content, cb);
			},
			function(fileError) {
				self.handleError(fileError, cb, "write", filename);
			});
	},

	writeContent: function(fileEntry, content, cb)
	{
		var self = this;

		fileEntry.createWriter(
			function(fileWritter)
			{
				fileWritter.onwriteend = function()
				{
					fileWritter.onwriteend = function()
					{
						if(cb) {
							cb(content);
						}
					}

					var blob = new Blob([ content ], { type: "text/plain" });
					fileWritter.write(blob);
				};

				fileWritter.onerror = function()
				{
					console.error("(FileSystem::write) Could not write in " + fileEntry.name);
					if(cb) {
						cb(null);
					}
				};

				fileWritter.truncate(1);
			},
			function(fileError) {
				self.handleError(fileError, cb, "createWritter", filename);
			});
	},

	writeBlob: function(filename, blob, cb)
	{
		var self = this;

		this.fs.getFile(this.rootDir + filename, { create: true },
			function(fileEntry) {
				self.handleWriteBlobDone(fileEntry, blob, cb);
			},
			function(fileError) {
				self.handleError(fileError, cb, "writeBlob", filename);
			});
	},

	handleWriteBlobDone: function(fileEntry, blob, cb)
	{
		var self = this;

		fileEntry.createWriter(
			function(fileWritter)
			{
				fileWritter.onwriteend = function()
				{
					fileWritter.onwriteend = function()
					{
						if(cb) {
							cb(fileEntry.toURL());
						}
					}

					fileWritter.write(blob);
				};

				fileWritter.onerror = function()
				{
					console.error("(FileSystem::writeBlob) Could not write blob in " + fileEntry.name);
					if(cb) {
						cb(null);
					}
				};

				fileWritter.truncate(1);
			},
			function(fileError) {
				self.handleError(fileError, cb, "createWritter", filename);
			});
	},

	remove: function(filename, cb)
	{
		var self = this;

		this.fs.getFile(this.rootDir + filename, { create: false },
			function(fileEntry)
			{
				fileEntry.remove(
					function()
					{
						if(cb) {
							cb(fileEntry.toURL());
						}
					},
					function(fileError) {
						self.handleError(fileError, cb, "remove", filename);
					});
			},
			function(fileError) {
				self.handleError(fileError, cb, "remove", filename);
			});
	},

	moveTo: function(path, targetPath, cb)
	{
		var self = this;

		var targetPathIndex = targetPath.lastIndexOf("/") + 1;

		this.fs.getFile(this.rootDir + path, {},
			function(fileEntry)
			{
				self.fs.getDirectory(self.rootDir + targetPath.substr(0, targetPathIndex), {},
					function(dirEntry)
					{
						fileEntry.moveTo(dirEntry, targetPath.substr(targetPathIndex),
							function(fileEntry)
							{
								if(cb) {
									cb(fileEntry.toURL());
								}
							},
						function(fileError) {
							self.handleError(fileError, cb, "rename", path);
						});
					},
					function(fileError) {
						self.handleError(fileError, cb, "rename-getDir", path);
					});
			},
			function(fileError) {
				self.handleError(fileError, cb, "rename-getFile", path);
			});
	},

	checkDir: function(name, cb)
	{
		var self = this;

		this.fs.getDirectory(this.rootDir + name, {},
			function(dirEntry)
			{
				if(cb) {
					cb(dirEntry.toURL());
				}
			},
			function(fileError) {
				self.handleError(fileError, cb, "checkDir", name);
			});
	},

	readDir: function(name, cb)
	{
		var self = this;

		this.fs.getDirectory(this.rootDir + name, {},
			function(dirEntry)
			{
				var dirReader = dirEntry.createReader();
				var entries = [];

				dirReader.readEntries(
					function(results)
					{
						if(results.length) {
							entries = entries.concat(results);
						}

						if(cb) {
							cb(entries);
						}
					},
					function(fileError) {
						self.handleError(fileError, cb, "readDir", name);
					});
			},
			function(fileError) {
				self.handleError(fileError, cb, "readDir", name);
			});
	},

	createDir: function(name, cb)
	{
		var self = this;

		this.fs.getDirectory(this.rootDir + name, { create: true },
			function(dirEntry)
			{
				if(cb) {
					cb(dirEntry.toURL());
				}
			},
			function(fileError) {
				self.handleError(fileError, cb, "createDir", name);
			});
	},

	removeDir: function(name, cb)
	{
		var self = this;

		this.fs.getDirectory(this.rootDir + name, {},
			function(dirEntry)
			{
				dirEntry.removeRecursively(
					function()
					{
						if(cb) {
							cb(dirEntry.toURL());
						}
					},
					function(fileError) {
						self.handleError(fileError, cb, "remove", filename);
					});
			},
			function(fileError) {
				self.handleError(fileError, cb, "removeDir", name);
			});
	},

	moveToDir: function(path, targetPath, cb)
	{
		var self = this;

		var targetPathIndex = targetPath.lastIndexOf("/") + 1;

		this.fs.getDirectory(this.rootDir + path, {},
			function(parentDirEntry)
			{
				self.fs.getDirectory(self.rootDir + targetPath.substr(0, targetPathIndex), {},
					function(dirEntry)
					{
						parentDirEntry.moveTo(dirEntry, targetPath.substr(targetPathIndex),
							function(newDirEntry)
							{
								if(cb) {
									cb(newDirEntry.toURL());
								}
							},
						function(fileError) {
							self.handleError(fileError, cb, "rename", path);
						});
					},
					function(fileError) {
						self.handleError(fileError, cb, "rename-getDir", path);
					});
			},
			function(fileError) {
				self.handleError(fileError, cb, "rename-getParentDir", path);
			});
	},

	handleError: function(fileError, cb, type, filename)
	{
		if(type === "read" && fileError.name !== "NotFoundError")
		{
			if(filename) {
				console.error("(editor.fileSystem) [" + type + "]", "[" + filename + "]", fileError.name);
			}
			else {
				console.error("(editor.fileSystem) [" + type + "]", fileError.name);
			}
		}

		if(cb) {
			cb(null);
		}
	},

	//
	fs: null,

	rootDir: "",
	ready: false
};

"use strict";

editor.fileSystemLocal = 
{
	init: function() {
		this.fs = require("fs");
		editor.handleFsReady();
	},

	read: function(path, cb)
	{
		this.fs.readFile(this.rootDir + path,
			function(error, data)
			{
				if(error)
				{
					if(cb) {
						cb(null);
					}

					return;
				}

				if(cb) {
					cb(data.toString());
				}
			});
	},

	create: function(path, cb)
	{
		var self = this;

		var fullPath = this.rootDir + path;
		this.fs.writeFile(fullPath, "",
			function(error)
			{
				if(error) {
					self.handleError("create", error, cb);
					return;
				}

				if(cb) {
					cb(fullPath);
				}
			});
	},

	write: function(path, content, cb)
	{
		var self = this;

		var fullPath = this.rootDir + path;
		this.fs.writeFile(fullPath, content,
			function(error)
			{
				if(error) {
					self.handleError("write", error, cb);
					return;
				}

				if(cb) {
					cb(content);
				}
			});
	},

	writeBase64: function(path, base64, cb)
	{
		var self = this;

		var index = base64.indexOf(",");
		var base64Data = base64.slice(index);
		base64Data += base64Data.replace("+", " ");
		var binaryData = new Buffer(base64Data, "base64").toString("binary");

		var fullPath = this.rootDir + path;
		this.fs.writeFile(fullPath, binaryData, "binary",
			function(error)
			{
				if(error) {
					self.handleError("write64", error, cb);
					return;
				}

				if(cb) {
					cb(path);
				}
			});
	},

	remove: function(path, cb)
	{
		var self = this;

		this.fs.unlink(this.rootDir + path,
			function(error)
			{
				if(error) {
					self.handleError("remove", error, cb);
					return;
				}

				if(cb) {
					cb(path);
				}
			});
	},

	moveTo: function(path, targetPath, cb)
	{
		var self = this;

		this.fs.rename(this.rootDir + path, this.rootDir + targetPath,
			function(error)
			{
				if(error) {
					self.handleError("moveTo", error, cb);
					return;
				}

				if(cb) {
					cb(path);
				}
			});
	},

	checkDir: function(path, cb)
	{
		var self = this;

		this.fs.exists(this.rootDir + path,
			function(error)
			{
				if(error) {
					self.handleError("checkDir", error, cb);
					return;
				}

				if(cb) {
					cb(fullPath);
				}
			});
	},

	readDir: function(path, cb)
	{
		var self = this;

		this.fs.readdir(this.rootDir + path,
			function(error, files)
			{
				if(error) {
					self.handleError("readDir", error, cb);
					return;
				}

				if(cb) {
					cb(files);
				}
			});
	},

	createDir: function(path, cb)
	{
		var self = this;

		var fullPath = this.rootDir + path;
		this.fs.exists(fullPath,
			function(error)
			{
				if(error) {
					self.handleError("createDir", "There is already folder with in: " + fullPath, cb);
					return;
				}

				self.fs.mkdir(fullPath,
					function(error)
					{
						if(error) {
							self.handleError("createDir", error, cb);
							return;
						}

						if(cb) {
							cb(fullPath);
						}
					});
			});
	},

	removeDir: function(path, cb)
	{
		var self = this;

		this.fs.readdir(this.rootDir + path,
			function(error, files)
			{
				if(error) {
					self.handleError("removeDir", error, cb);
					return;
				}

				var wait = files.length;
				var count = 0;
				var folderDone = function(error)
				{
					count++;
					if(count >= wait || error)
					{
						self.fs.rmdir(self.rootDir + path,
							function(error)
							{
								if(error) {
									self.handleError("removeDir", error, cb);
									return;
								}

								if(cb) {
									cb(self.rootDir + path);
								}
							});
					}
				};

				if(!wait) {
					folderDone(null);
					return;
				}

				path = path.replace(/\/+$/,"");
				files.forEach(
					function(file)
					{
						var currPath = path + "/" + file;
						self.fs.lstat(self.rootDir + currPath,
							function(error, stats)
							{
								if(error) {
									self.handleError("removeDir", error, cb);
									return;
								}

								if(stats.isDirectory()) {
									self.removeDir(currPath, folderDone);
								}
								else {
									self.fs.unlink(self.rootDir + currPath, folderDone);
								}
							});
					});
		});
	},

	moveToDir: function(path, targetPath, cb)
	{
		var self = this;

		this.fs.rename(this.rootDir + path, this.rootDir + targetPath,
			function(error)
			{
				if(error) {
					self.handleError("moveToDir", error, cb);
					return;
				}

				if(cb) {
					cb(path);
				}
			});
	},

	handleError: function(type, error, cb)
	{
		console.error("(editor.fileSystemLocal." + type + ")", error);
		if(cb) {
			cb("");
		}
	},

	//
	rootDir: "",
	fullPath: ""
};

"use strict";

meta.onDomLoad(function() 
{
	editor.prepare();
});

"use strict";

editor.plugin.basic = function()
{
	if(this.create) {
		this.create();
	}
};

editor.plugin.basic.prototype =
{
	create: null,

	onSplashStart: null,

	onSplashEnd: null
};

"use strict";

function dataURItoBlob(dataURI, type)
{
	var binary = atob(dataURI.split(",")[1]);
	var length = binary.length;
	var array = new Uint8Array(length);

	for(var n = 0; n < length; n++) {
	    array[n] = binary.charCodeAt(n);
	}

	return new Blob([ array ], { type: type });
}

meta.selectElementContents = function(element)
{
	var range = document.createRange();
	range.selectNodeContents(element);

	var selection = window.getSelection();
	selection.removeAllRanges();
	selection.addRange(range);
};

meta.mergeObjects = function(a, b)
{
	var output = {};

	for(var key in a) {
		output[key] = a[key];
	}

	meta.mergeAppend(output, b);

	return output;
};

meta.appendObject = function(target, src)
{
	var value, targetValue;
	for(var key in src)
	{
		if(src.hasOwnProperty(key))
		{
			value = src[key];
			if(typeof(value) === "object")
			{
				targetValue = target[key];

				if(!targetValue)
				{
					if(value instanceof Array) {
						targetValue = [].concat(value);
					}
					else {
						targetValue = {};
						meta.appendObject(targetValue, value);
					}

					target[key] = targetValue;
				}
				else if(typeof(targetValue) === "object")
				{
					if(value instanceof Array)
					{
						if(targetValue instanceof Array) {
							target[key] = targetValue.concat(value);
						}
						else {
							console.warn("(meta.mergeAppend) Incompatible types for '" + key + "' key");
						}
					}
					else
					{
						if(targetValue instanceof Array) {
							console.warn("(meta.mergeAppend) Incompatible types for '" + key + "' key");
						}
						else {
							meta.appendObject(targetValue, value);
						}
					}
				}
				else {
					console.warn("(meta.mergeAppend) Incompatible types for '" + key + "' key");
				}
			}
			else {
				target[key] = src[key];
			}
		}
	}
};



"use strict";

editor.config = {
	version: "0.1",
	titlePrefix: "MetaEditor",
	wsUrl: ((window.location.protocol === "https:") ? "wss://" : "ws://") + window.location.host + ":8080",
	httpUrl: window.location.protocol + '//' + window.location.host
};

"use strict";

editor.plugin("browser",
{
	create: function()
	{
		wabi.addTemplate("browserHierarchy", {
			type: "panel",
			$header: "Hierarchy",
			$value: [
				{
					id: "hierarchy",
					type: "list",
					itemCls: "browserListItem",
					bind: "*"
				}
			]
		});

		wabi.addTemplate("browserResources", {
			type: "panel",
			$header: "Resources",
			$value: [
				{
					id: "resources",
					type: "list",
					itemCls: "browserListItem",
					bind: "*"
				},
				{
					type: "upload",
					hidden: true
				}
			]
		});

		wabi.addTemplate("browserDefs", {
			type: "panel",
			$header: "Defs",
			$value: [
				{
					id: "defs",
					type: "list",
					itemCls: "browserListItem",
					bind: "*"
				}
			]
		});

		editor.plugins.contextmenu.add("resources", {
			Create: {
				type: "category",
				content: {
					Folder: {
						icon: "fa-folder",
						func: this.createFolder.bind(this)
					}
				}
			},
			Actions: {
				type: "category",
				content: {
					Upload: {
						icon: "fa-upload",
						func: this.upload.bind(this)
					}
				}
			}
		});

		editor.plugins.contextmenu.add("resourcesItem", "resources", {
			Actions: {
				type: "category",
				content: {
					Delete: {
						icon: "fa-trash",
						func: this.deleteResourceItem.bind(this)
					}
				}
			}
		});
	},

	install: function()
	{
		editor.dataPublic.setKeys({
			hierarchy: {},
			resources: {},
			defs: {}
		});
	},

	onStart: function()
	{
		this.loadData();

		var content = editor.plugins.layout.toolbarBrowser.elements.content;
		content.setCls("browser", true);

		this.createHierarchyPanel(content, this.cache);

		this.cache = this.browserHierarchy.get("#hierarchy").cache;

		this.createResourcePanel(content, this.cache);
		this.createDefsPanel(content, this.cache);
	},

	createHierarchyPanel: function(parent, cache)
	{
		this.browserHierarchy = wabi.createTemplate("browserHierarchy");
		this.browserHierarchy.data = this.hierarchy;
		this.browserHierarchy.on("contextmenu", "list", function(event) {
			editor.plugins.contextmenu.show("hierarchy", event.x, event.y);
		});
		this.browserHierarchy.on("contextmenu", "browserListItem", function(event) {
			this.openContextMenu("hierarchyItem", event);
		}, this);
		this.browserHierarchy.on("click", "*", this.inspectItem, this);
		this.browserHierarchy.appendTo(parent);		
	},

	createResourcePanel: function(parent, cache)
	{
		this.browserResources = wabi.createTemplate("browserResources");
		this.browserResources.get("#resources").cache = this.cache;
		this.browserResources.data = this.resources;
		this.browserResources.on("click", "browserListItem", this.inspectItem, this);
		this.browserResources.on("drop", [ "list", "browserListItem" ], this.handleResourceDrop, this);
		this.browserResources.on("dragenter", [ "list", "browserListItem" ], this.handleDragEnter, this);
		this.browserResources.on("dragleave", [ "list", "browserListItem" ], this.handleDragLeave, this);

		var list = this.browserResources.get("list")[0];
		list.on("contextmenu", function(event) {
			editor.plugins.contextmenu.show("resources", event.x, event.y);
		});
		list.on("contextmenu", "browserListItem", function(event) {
			this.openContextMenu("resourcesItem", event);
		}, this);

		this.resourceUpload = this.browserResources.get(wabi.element.upload)[0];
		this.resourceUpload.on("change", this.handleUpload, this);
		
		this.browserResources.appendTo(parent);		
	},

	createDefsPanel: function(parent, cache)
	{
		this.browserDefs = wabi.createTemplate("browserDefs");
		this.browserDefs.get("#defs").cache = this.cache;
		this.browserDefs.data = this.defs;
		this.browserDefs.on("contextmenu", "list", function(event) {
			editor.plugins.contextmenu.show("defs", event.x, event.y);
		});
		this.browserDefs.on("contextmenu", "browserListItem", function(event) {
			this.openContextMenu("defsItem", event);
		});
		this.browserDefs.on("click", "browserListItem", this.inspectItem, this);

		var list = this.browserDefs.get("list")[0];

		this.browserDefs.appendTo(parent);		
	},

	loadData: function()
	{
		this.hierarchy = editor.dataPublic.get("hierarchy");
		this.resources = editor.dataPublic.get("resources");
		this.defs = editor.dataPublic.get("defs");
	},

	updateIcons: function(buffer)
	{
		var resources = editor.plugins.resources;

		for(var key in buffer)
		{
			var item = buffer[key];
			item.icon = resources.getIconFromType(item.type);
		}
	},

	createFolder: function(event) {
		this.browserResources.get("#resources").createFolder();
		// event.element.createFolder();
	},

	upload: function() {
		this.resourceUpload.open();
	},

	handleUpload: function(event) 
	{
		var files = event.element.files;
		for(var n = 0; n < files.length; n++) {
			this.readFile(files[n]);
		}
	},

	handleDragEnter: function(event) {
		event.stop();
		event.element.setCls("dragover", true);
	},

	handleDragLeave: function(event) {
		event.stop();
		event.element.setCls("dragover", false);
	},

	handleResourceDrop: function(event)
	{
		event.stop();

		if(meta.device.name === "Chrome") {
			this.handleFileSelect_Chrome(event.domEvent);
		}
		else {
			this.handleFileSelect_All(event.domEvent);
		}

		this.handleDragLeave(event);
	},

	handleFileSelect_All: function(domEvent)
	{
		var files = domEvent.dataTransfer.files;
		var num = files.length;

		for(var n = 0; n < num; n++) {
			this.readFile(files[n]);
		}
	},

	handleFileSelect_Chrome: function(domEvent)
	{
		var entry;
		var dataItems = domEvent.dataTransfer.items;
		var numDataItems = dataItems.length;
		for(var n = 0; n < numDataItems; n++)
		{
			entry = dataItems[n].webkitGetAsEntry();
			if(entry) {
				this.handleFileSelect_Chrome_traverseDir(entry);
			}
		}
	},

	handleFileSelect_Chrome_traverseDir: function(entry)
	{
		var self = this;

		if(entry.isFile)
		{
			entry.file(
				function(file) {
					self.readFile(file);
				});
		}
		else if(entry.isDirectory)
		{
			var dirReader = entry.createReader();
			dirReader.readEntries(
				function(entries)
				{
					var num = entries.length;
					for(var n = 0; n < num; n++) {
						self.handleFileSelect_Chrome_traverseDir(entries[n]);
					}
				});
		}
	},

	readFile: function(file)
	{
		this.numItemsLoading++;

		var self = this;
		var reader = new FileReader();
		reader.onload = function(fileResult) 
		{
			editor.writeFile(file, fileResult, function(hash, type) {
				self.resources.add(hash, "*" + type + "." + hash);
			});
		};

		reader.readAsDataURL(file);
	},

	_handleOnFileLoad: function(path, currList, info)
	{
		this.addItem(currList, info);

		this.numItemsLoading--;
		if(this.numItemsLoading === 0) {
		}
	},

	openContextMenu: function(menuId, event)
	{
		editor.plugins.contextmenu.show(menuId, event.x, event.y);
		this.inspectItem(event);
	},

	inspectItem: function(event) {
		console.log("INSPECT")
		event.target.select = true;
		editor.plugins.inspect.show(event.target.data);
	},

	deleteItem: function(event)
	{

	},

	deleteResourceItem: function(event)
	{
		var selected = this.cache.selected;
		if(!selected) { return; }

		editor.deleteFile(selected.data);	
	},

	//
	hierarchy: null,
	resources: null,
	defs: null,

	browserHierarchy: null,
	browserResources: null,
	browserDefs: null,

	resourceUpload: null,
	cache: null
});

"use strict";

wabi.element("browserListItem", "listItem",
{
	elements: 
	{
		caret: {
			type: null,
			link: "open"
		},
		icon: {
			type: "type",
			link: "type",
			bind: "type"
		},
		name: {
			type: "word",
			link: "value",
			bind: "value"
		},
		tag: {
			type: null,
			bind: "ext"
		}
	},

	setup: function() {
		// this.attrib("draggable", "true");
	},

	set_folder: function(value) {
		this.element("caret", value ? "caret" : null);
	},

	set_tag: function(value) 
	{
		if(value)
		{
			this.element("tag", "tag");
			this.elements.tag.$value = value;
		}
		else
		{
			this.element("tag", null);
		}
	},

	handle_dblclick: function(event)
	{
		if(!this.elements.caret) { return; }

		this.elements.caret.$value = !this.elements.caret.$value;
	},

	handle_dragenter: function(event) 
	{
		// if(event.element === this) { return; }

		this.setCls("dragover", true);
	},

	handle_dragleave: function(event) 
	{
		// if(event.element === this) { return; }

		this.setCls("dragover", false);
	},

	// handle_dragstart: function(event) 
	// {
	// 	this.setCls("dragging", true);
	// 	this.cache.dragging = this;

	// 	event.domEvent.dataTransfer.effectAllowed = "move";
	// },

	// handle_dragend: function(event) 
	// {
	// 	this.setCls("dragging", false)
	// },

	// handle_dragenter: function(event) 
	// {
	// 	if(event.element === this) { return; }

	// 	this.setCls("dragover", true);
	// },

	// handle_dragleave: function(event) 
	// {
	// 	if(event.element === this) { return; }

	// 	this.setCls("dragover", false);
	// },

	// handle_dragover: function(event)
	// {
	// 	if(event.element === this) { return; }

	// 	var bounds = this.domElement.getBoundingClientRect();
	// 	// console.log(bounds);
	// 	// console.log("cursor", event.x, event.y)

	// 	if((bounds.top + 5) <= event.y) {
	// 		console.log("drag-top");
	// 		return;
	// 	}
	// 	else if((bounds.bottom - 5) >= event.y) {
	// 		console.log("drag-bottom")
	// 		return;
	// 	}

	// 	event.stop();
	// 	event.domEvent.dataTransfer.dropEffect = "move";
	// },

	// handle_drop: function(event) 
	// {
	// 	if(event.element === this) { return; }

	// 	this.setCls("dragover", false);
	// 	this.folder = true;

	// 	var cacheData = this.cache.dragging.data;
	// 	this.data.push("content", cacheData);

	// 	event.stop();
	// },
});

"use strict";

wabi.element("highlight",
{
	set_value: function(value) 
	{
		this.$domElement.innerHTML = value;
		// this.setCls("active", true)

		if(this.value && value) 
		{
			console.log("active")
			this.setCls("active", true);
			var self = this;
			setTimeout(function() {
				self.setCls("active", false);
			}, 1000)		

		}		
	}
});

"use strict";

wabi.element("type", 
{
	set_value: function(value, prevValue) 
	{
		var icon = editor.plugins.resources.getIconFromType(value);

		this.attrib("class", "fa", true);
		this.setCls(icon, true);
	}
});
"use strict";

wabi.element("wordEx",
{
	elements: 
	{
		word: {
			type: "word",
			link: "value",
			bind: "value"
		},
		highlight: {
			type: "highlight"
		}
	},

	set_value: function(value) {
		this.elements.highlight.$value = value;
	}
});

"use strict";

editor.plugin("contextmenu",
{
	create: function()
	{
		this.menus = {};

		this.contextmenu = wabi.createElement("contextmenu", editor.overlayElement);
		this.contextmenu.hidden = true;

		wabi.on("click", this.handleClick, this);
		wabi.on("contextmenu", this.handleContextmenu, this);
	},

	add: function(id, extend, props)
	{
		if(!props) {
			props = extend;
			extend = null;
		}

		if(!props) {
			console.warn("(plugin.contextmenu.add) Invalid properties passed for id: " + id);
			return;
		}

		var menu = this.menus[id];
		if(!menu) 
		{
			var processedProps = {};
			this.processProps(processedProps, props);

			menu = new this.Menu(id, extend, processedProps);
			this.menus[id] = menu;
		}
		else 
		{
			this.processProps(menu.props, props);

			if(extend) 
			{
				if(menu.extend) {
					menu.extend.push(extend);
				}
				else {
					menu.extend = [ extend ];
				}
			}
		}
	},

	processProps: function(src, props)
	{
		for(var key in props)
		{
			var state = props[key];
			var prevState = src[key];

			if(!state) 
			{
				if(!prevState) {
					src[key] = { value: key };
				}
			}
			else if(state instanceof Function) 
			{
				if(prevState) {
					prevState.func = state;
				}
				else {
					src[key] = { value: key, func: state };
				}
			}
			else if(state instanceof Object) 
			{
				if(prevState)
				{
					if(state.value && state.value !== prevState.value) {
						prevState.value = state.value;
					}

					if(state.content) {
						this.processProps(prevState.content, state.content);
					}
				}
				else
				{
					if(!state.value) {
						state.value = key;
					}

					if(state.content) 
					{
						if(!state.type) {
							state.type = "category";
						}

						var content = {};
						this.processProps(content, state.content);
						state.content = content;
					}

					src[key] = state;
				}

			}
		}
	},

	show: function(id, x, y)
	{
		var menu = this.menus[id];
		if(!menu) {
			console.warn("(plugin.contextmenu.show) No such context menu found: " + id);
			return;
		}

		if(menu.extend) 
		{
			var props = {};
			this.extendMenu(props, menu);
			this.contextmenu.$value = props;
		}
		else 
		{
			this.contextmenu.$value = menu.props;
		}

		this.contextmenu.position(event.x, event.y);
		this.contextmenu.hidden = false;
	},

	extendMenu: function(src, menu)
	{
		if(menu.extend) 
		{
			var extend = menu.extend;
			for(var n = 0; n < extend.length; n++) 
			{
				var extendId = extend[n];
				var extendMenu = this.menus[extendId];
				if(!extendMenu) {
					console.warn("(plugin.contextmenu.extendMenu) No such context menu found: " + extendId);
					continue;
				}

				this.extendMenu(src, extendMenu)
			}
		}

		this.mergeProps(src, menu.props);
	},

	mergeProps: function(src, props)
	{
		for(var key in props)
		{
			var state = props[key]
			var prevState = src[key];

			if(!prevState) 
			{
				var newState = {};
				Object.assign(newState, state);
				if(newState.content) {
					newState.content = {};
					Object.assign(newState.content, state.content);
				}

				src[key] = newState;
			}
			else
			{
				if(prevState.value !== state.value) {
					prevState.value = state.value;
				}

				if(state.content) 
				{
					if(prevState.content) {
						this.mergeProps(prevState.content, state.content);
					}
					else {
						prevState.content = {};
						Object.assign(prevState.content, state.content);
					}
				}
			}
		}
	},

	hide: function() {
		this.contextmenu.hidden = true;
	},

	handleClick: function(event) {
		this.contextmenu.hidden = true;
	},

	handleContextmenu: function(event) {
		event.domEvent.preventDefault();
		this.hide();
	},

	Menu: function(id, extend, props)
	{
		this.id = id;
		this.props = props;
		this.extend = extend ? [ extend ] : null;
	},

	//
	menus: null,
	contextmenu: null
});

"use strict";

wabi.element("contextmenu",
{
	state: {
		x: 0,
		y: 0
	},

	elements: 
	{
		inner: {
			type: "contextmenuInner",
			link: "value"
		}
	},

	position: function(x, y) {
		this.$x = x;
		this.$y = y;
	},

	set_x: function(value) {
		this.style("left", value + "px");
	},

	set_y: function(value) {
		this.style("top", value + "px");
	}
});

wabi.element("contextmenuItem",
{
	state: {
		func: null
	},

	elements: 
	{
		icon: {
			type: "icon",
			link: "icon"
		},
		text: {
			type: "text",
			link: "value"
		}
	},

	prepare: function() {
		this.on("click", "*", this.handle_click, this);
	},

	handle_click: function(event)
	{
		if(this.$func) {
			this.$func(event);
		}
	},

	//
	tag: "item"
});

wabi.element("contextmenuCategory",
{
	elements: 
	{
		header: {
			type: "contextmenuHeader",
			link: "value"
		},
		content: {
			type: "contextmenuInner",
			link: "content"
		}
	},

	set_icon: function(value) {
		this.elements.header.$icon = value;
	},

	//
	tag: "category"
});

wabi.element("contextmenuInner",
{
	set_value: function(value)
	{
		this.removeAll();

		if(!value) { return; }

		for(var key in value) {
			this.createItem(key, value[key]);
		}
	},

	createItem: function(name, state)
	{
		var element;

		if(state.type === "category") {
			element = wabi.createElement("contextmenuCategory", this);
		}
		else {
			element = wabi.createElement("contextmenuItem", this);
		}

		console.log(state)
		element.$ = state;
	},

	//
	tag: "inner"
});

wabi.element("contextmenuHeader",
{
	elements: 
	{
		icon: {
			type: "icon",
			link: "icon"
		},
		value: {
			type: "text",
			link: "value"
		},
	},

	//
	tag: "header"
});

"use strict";

wabi.element("image",
{
	prepare: function() {
		this.img = document.createElement("img");
		this.domElement.appendChild(this.img);
	},

	set_value: function(value) 
	{
		if(value) {
			this.img.src = editor.projectPath + value + "." + this.data.get("ext");
		}
		else {
			this.img.src = "";
		}
	},

	//
	img: null
});

"use strict";

wabi.element("labelName",
{
	elements: 
	{
		name: {
			type: "text",
			link: "name"
		},
		content: {
			type: "input",
			link: "value"
		}
	},

	//
	tag: "label"
});

wabi.element("labelNumber",
{
	elements: 
	{
		name: {
			type: "text",
			link: "name"
		},
		content: {
			type: "number",
			link: "value"
		}
	},

	//
	tag: "label"
});

wabi.element("labelDropdown",
{
	elements: 
	{
		name: {
			type: "text",
			link: "name"
		},
		dropdown: {
			type: "dropdown",
			link: "value"
		}
	},

	set_dataset: function(value) {
		this.elements.dropdown.$dataset = value;
	},

	set_emptyOption: function(value) {
		this.elements.dropdown.$emptyOption = value;
	},

	//
	tag: "label"
});

wabi.element("labelCheckbox",
{
	elements: 
	{
		name: {
			type: "text",
			link: "name"
		},
		content: {
			type: "checkbox",
			link: "value"
		}
	},

	//
	tag: "label"
});


"use strict";

wabi.element("section",
{
	elements: 
	{
		header: {
			type: "headerEx",
			link: "name",
			watch_open: "updateOpen"
		},
		content: {
			type: "content",
			link: "value"
		}
	},

	updateOpen: function(value) {
		this.elements.content.hidden = !value;
	},

	set open(value) {
		this.elements.header.open = value;
	},

	get open() {
		return this.elements.header.open;
	}
});

"use strict";

wabi.element("taggedNumber",
{
	state: {
		color: "#000"
	},

	elements: 
	{
		name: {
			type: "text",
			link: "name"
		},
		number: {
			type: "number",
			link: "value"
		}
	},
	
	set_color: function(value) {
		this.elements.name.style("background-color", value);
	}
});

"use strict";

editor.plugin("inspect",
{
	create: function()
	{
		wabi.addFragment("inspect-general",
		{
			type: "section",
			$name: "General",
			$value: [
				{
					type: "labelName",
					bind: "@",
					$name: "Id"
				},			
				{
					type: "labelName",
					bind: "value",
					$name: "Name"
				}						
			]
		});

		wabi.addFragment("inspect-texture", "inspect-general",
		{
			type: "section",
			$name: "Texture",
			$value: [
				{
					type: "image",
					bind: "@",
				}
			]
		});
	},

	onStart: function()
	{
		var toolbarContent = editor.plugins.layout.toolbarInspect.elements.content;

		this.content = wabi.createElement("content");
		this.content.appendTo(toolbarContent);
	},

	add: function(id, props)
	{

	},

	show: function(data)
	{
		if(!data) {
			this.content.$value = "";
			this.content.data = null;
			return;
		}
		
		var props = wabi.getFragment("inspect-" + data.get("type"));
		if(!props) {
			props = wabi.getFragment("inspect-general");
		}

		this.content.data = null;
		this.content.$value = props;
		this.content.data = data;
	},

	//
	content: null,
	toolbarContent: null
});

"use strict";

wabi.element("ruler", 
{
	state: {
		orientation: ""
	},

	elements:
	{
		canvas: "canvas",
		cursor: "div"
	},

	prepare: function() {
		this.on("mousemove", "*", this.updateMouseMove, this);
	},

	cleanup: function() {
		wabi.off("resize", this.updateResize, this);
	},

	set_orientation: function(value) {
		this.attrib("class", value);
	},

	updateMouseMove: function(event)
	{
		var bounds = event.element.domElement.getBoundingClientRect();
		var cursor;

		switch(this.$orientation)
		{
			case "horizontal":
				cursor = event.x - bounds.left;
				break;

			case "vertical":
				cursor = event.y - bounds.top;
				break;
		}

		this.updateCursor(cursor);
	},

	updateCursor: function(cursor)
	{
		switch(this.$orientation)
		{
			case "horizontal":
				this.elements.cursor.style("left", cursor + "px");
				break;

			case "vertical":
				this.elements.cursor.style("top", cursor + "px");
				break;
		}
	},

	redrawRegion: function(from, to)
	{
		var canvas = this.elements.canvas;
		var canvasElement = canvas.domElement;

		var ctx = canvas.ctx;
		ctx.clearRect(from, 0, to, canvasElement.height);
		ctx.font = "13px Calibri";
		ctx.fillStyle = "gray";
		ctx.strokeStyle = "gray";
		ctx.textBaseline = "middle";
		ctx.beginPath();

		var step;
		switch(this.$orientation) 
		{
			case "horizontal":
				step = 128;
				break;

			case "vertical":
				step = 96;
				break;
		}

		var remainder = this.position  % step;
		var currStep = this.position / step;

		var pos, num;
		if(this.position > 0) 
		{
			currStep = Math.floor(currStep) + 1;
			pos = (this.position % step) + 0.5 - step;
			num = Math.ceil(((to - from) - remainder) / step) + 1;
		}
		else
		{
			currStep = Math.ceil(currStep);
			pos = (this.position % step) + 0.5;
			num = Math.ceil(((to - from) - remainder) / step);
		}

		currStep *= -step;

		switch(this.$orientation)
		{
			case "horizontal":
			{
				for(var n = 0; n < num; n++) 
				{
					if(pos > 0.5)
					{
						ctx.moveTo(pos, 0);
						ctx.lineTo(pos, canvasElement.height);
					}

					ctx.fillText(currStep, pos + 2, 11);
					pos += step;
					currStep += step;
				}
			} break;

			case "vertical":
			{
				for(var n = 0; n < num; n++) 
				{
					if(pos > 0.5)
					{					
						ctx.moveTo(0, pos);
						ctx.lineTo(canvasElement.width, pos);
					}

					var offset = canvasElement.width / 2 - 2;
					ctx.save();
					ctx.translate(offset, pos + 3);
					ctx.rotate(Math.PI / 2);
					ctx.translate(-offset, -pos - 3)
					ctx.fillText(currStep, offset, pos + 3);
					ctx.restore();

					pos += step;
					currStep += step;
				}
			} break;
		}

		ctx.stroke();
	},

	updateSize: function() 
	{
		var canvasElement = this.elements.canvas.domElement;
		canvasElement.width = this.domElement.offsetWidth;
		canvasElement.height = this.domElement.offsetHeight;

		switch(this.$orientation) 
		{
			case "horizontal":
				this.redrawRegion(0, canvasElement.width);
				break;

			case "vertical":
				this.redrawRegion(0, canvasElement.height);
				break;
		}
	},

	updatePos: function(position)
	{
		this.position = -position;

		var canvasElement = this.elements.canvas.domElement;

		switch(this.$orientation) 
		{
			case "horizontal":
				this.redrawRegion(0, canvasElement.width);
				break;

			case "vertical":
				this.redrawRegion(0, canvasElement.height);
				break;
		}
	},

	//
	position: 0
});

"use strict";

wabi.element("tabs",
{
	set_value: function(value)
	{
		this.removeAll();

		var tab;

		if(typeof(value) === "string")
		{
			tab = wabi.createElement("tab", this);
			tab.$value = value;
		}
		else if(value instanceof Array)
		{
			for(var n = 0; n < value.length; n++)
			{
				tab = wabi.createElement("tab", this);
				tab.$value = value[n];
			}
		}
		else {
			return;
		}

		this.children[0].$active = true;
	}
});

wabi.element("tab",
{
	state: {
		active: true
	},

	set_value: function(value) {
		this.html(value);
	},

	set_active: function(value) {
		this.setCls("active", true);
	},

	//
	tabContent: null
});

"use strict";

wabi.element("toolbar",
{
	elements: 
	{
		tabs: {
			type: "tabs",
			link: "tab"
		},
		content: {
			type: "content",
			link: "value"
		}
	},

	set width(value) 
	{
		if(value > 0)
		{
			this.style("flex", "0 0 " + value + "px");
		}
	},

	get width() {
		return this._width;
	},

	//
	_width: 0
});

"use strict";

editor.plugin("layout",
{
	create: function()
	{
		wabi.addTemplate("layout", {
			type: "content",
			$value: [
				{
					id: "browser",
					type: "toolbar",
					width: 270,
					$tab: "Project",
				},
				{
					type: "toolbar",
					$tab: "master",
					$value: [				
						{
							id: "ruler-row-horizontal",
							type: "row",
							$value: [
								{
									type: "div"
								},
								{
									id: "ruler-horizontal",
									type: "ruler",
									$orientation: "horizontal"
								},
							]
						},
						{
							type: "row",
							$value: [
								{
									id: "ruler-vertical",
									type: "ruler",
									$orientation: "vertical"
								},
								{
									id: "iframe",
									type: "div"
								}
							]
						}						
						
					]
				},
				{
					id: "inspect",
					type: "toolbar",
					width: 380,
					$tab: "Inspect"
				}
			]
		});

		wabi.on("drop", this.handleDrop, this);
		wabi.on("dragover", this.handleDragOver, this);
	},

	onStart: function()
	{
		this.template = wabi.createTemplate("layout");
		this.toolbarBrowser = this.template.get("#browser");
		this.toolbarIFrame = this.template.get("#iframe");
		this.toolbarInspect = this.template.get("#inspect");
		this.template.appendTo(editor.wrapperElement);
	},

	handleDrop: function(event) {
		event.stop();
	},

	handleDragOver: function(event) {
		event.stop();
	},

	//
	template: null,
	toolbarBrowser: null,
	toolbarIFrame: null,
	toolbarInspect: null
});

"use strict";

editor.plugin("login", 
{
	create: function()
	{
		this.registerTemplates();

		// Load user data:
		var userData;
		var localUserData = localStorage.getItem("user");
		if(localUserData) {
			userData = JSON.parse(localUserData);
		}
		else 
		{
			userData = {
				username: "",
				password: ""
			};
		}

		editor.dataPrivate.set("user", userData);
		this.userData = editor.dataPrivate.get("user");
		this.userData.watch(this.onDataChange, this);
		this.registerData = new wabi.data({});
	},

	onDataChange: function(action, key, value, index, data)
	{
		if(key === "remember" && !value) {
			localStorage.setItem("user", null);
		}
	},

	show: function() 
	{
		editor.connection.on("close", this.onServer_close, this);
		editor.connection.on("register", this.onServer_register, this);
		editor.connection.on("login", this.onServer_login, this);

		this.loginScreen = wabi.createTemplate("loginScreen");
		this.loginScreen.appendTo(editor.overlayElement);
		this.showLogin(true);
	},

	hide: function() 
	{	
		editor.connection.off(this);

		this.loginScreen.remove();
	},

	onServer_close: function() 
	{
		this.loginScreen.get("#loader").hidden = true;

		if(!this.loginScreen.data.get("error")) {
			this.loginScreen.data.performSetKey("error", "NoServer");
		}
	},	

	onServer_register: function(data) 
	{
		this.loginScreen.get("#loader").hidden = true;

		if(data.error) {
			this.loginScreen.data.performSetKey("error", data.error);
			return;
		}

		this.registerData.performSetKey("username", null);
		this.registerData.performSetKey("password", null);

		this.showLogin();
	},

	onServer_login: function(data)
	{
		this.loginScreen.get("#loader").hidden = true;
		
		if(data.error) {
			this.loginScreen.data.performSetKey("error", data.error);
			return;
		}

		editor.login();
	},

	showLogin: function(autologin) 
	{
		this.userData.performSetKey("error", "");
		
		this.loginScreen.data = this.userData;
		this.loginScreen.$value = "loginScreen.login";
		this.loginScreen.on("click", "#register", this.handleRegisterAccount, this);
		this.loginScreen.on("click", "#login", this.handleLogin, this);

		if(autologin && this.userData.get("remember")) {
			this.validateAndSend("login");
		}
	},

	showRegister: function() 
	{
		this.loginScreen.data = this.registerData;
		this.loginScreen.$value = "loginScreen.register";
		this.loginScreen.on("click", "#back", this.handleBack, this);	
		this.loginScreen.on("click", "#register", this.handleCreateAccount, this);		
	},

	handleBack: function(event) {
		this.showLogin();
	},

	handleRegisterAccount: function(event) {
		this.showRegister();
	},

	handleLogin: function(event) 
	{
		if(!this.validateAndSend("login")) {
			return;
		}

		if(this.userData.get("remember")) {
			localStorage.setItem("user", JSON.stringify(this.userData));
		}
	},

	handleCreateAccount: function(event) {
		this.validateAndSend("register");
	},

	validateAndSend: function(action)
	{
		var data = this.loginScreen.data;
		var username = data.get("username");
		var password = data.get("password");

		if(!username || !password) {
			data.performSetKey("error", "RequiredFields");
			return false;
		}
		else {
			data.performSetKey("error", null);
		}

		this.loginScreen.get("#loader").hidden = false;
		this.emit({
			type: action,
			username: username,
			password: password
		});

		return true;
	},

	logout: function()
	{
		localStorage.removeItem("user");
		window.location.reload();
	},

	emit: function(data)
	{
		if(!editor.connection.open)
		{
			editor.connection.websocket.connect(
				function() {
					editor.connection.websocket.emit(data);	
				});
		}
		else {
			editor.connection.websocket.emit(data);	
		}		
	},

	registerTemplates: function()
	{
		wabi.addTemplate("loginScreen", {
			id: "loginScreen",
			type: "panel",
			width: 300,
			$header: "Login"
		});

		wabi.addFragment("loginScreen.error", {
			type: "error",
			bind: "error",
			$types: {
				AccountExist: "There is already an account registered with that name.",
				RequiredFields: "All fields must be filled.",
				NoServer: "Could not connect to server.",
				Wrong: "Wrong username or password."
			}
		});

		wabi.addFragment("loginScreen.login", [
			{
				type: "input",
				bind: "username",
				inputType: "name",
				placeholder: "Username"
			},
			{
				type: "input",
				bind: "password",
				inputType: "password",
				placeholder: "Password"
			},
			{
				type: "content",
				$value: [
					{
						type: "desc",
						$name: "Remember Me",
						$value: [
							{
								type: "checkbox",
								bind: "remember"
							}
						]
					}						
				],
				padding: 2
			},
			"loginScreen.error",		
			{
				type: "row",
				$value: [
					{
						type: "button",
						$value: "Guest"
					},					
					{
						id: "register",
						type: "button",
						$value: "Register"
					},
					{
						id: "login",
						type: "button",
						$value: "Login"
					}
				]
			},
			{
				id: "loader",
				type: "loader"
			}			
		]);

		wabi.addFragment("loginScreen.register", [
			{
				type: "input",
				bind: "username",
				inputType: "name",
				placeholder: "Username"
			},
			{
				type: "input",
				bind: "password",
				inputType: "password",
				placeholder: "Password"
			},
			"loginScreen.error",
			{
				type: "row",
				$value: [
					{
						id: "back",
						type: "button",
						value: "Back"
					},				
					{
						id: "register",
						type: "button",
						value: "Register"
					}
				]
			},
			{
				id: "loader",
				type: "loader"
			}			
		]);
	},

	//
	loginScreen: null,
	userData: null,
	registerData: null
});
"use strict";

wabi.element("menuitem",
{
	elements: 
	{
		icon: {
			type: "icon",
			link: "icon"
		},
		text: {
			type: "text",
			link: "value"
		},
		iconExt: {
			type: "icon",
			link: "iconExt"
		},
	}
});

"use strict";

editor.plugin("menubar",
{
	create: function()
	{
		wabi.addTemplate("topMenubar", 
		{
			type: "menubar",			
			right: [
				{
					type: "menuitem",
					bind: "username",
					icon: "fa-user",
					iconExt: "fa-caret-down"
				}
			]
		});
	},

	onSplashStart: function()
	{
		this.template = wabi.createTemplate("topMenubar");
		this.template.data = editor.dataPrivate.get("user");
		this.template.appendTo(editor.wrapperElement);
	},

	//
	template: null
});

"use strict";

editor.plugin("projects",
{
	create: function()
	{
		wabi.addTemplate("projects", {
			type: "panel",
			width: 300,
			$header: "Projects",
			$value: [
				{
					type: "content",
					height: 400,
					$value: {
						id: "projects-list",
						type: "list",
						bind: "*",
						itemCls: "editableListItem",
						placeholder: "No projects found",
					}
				},
				{
					id: "create",
					type: "button",
					$value: "Create"
				},
				{
					id: "loader",
					type: "loader",
					hidden: false
				}
			]
		});

		editor.plugins.contextmenu.add("projectItem", {
			Actions: {
				content: {
					Delete: {
						icon: "fa-trash",
						func: this.deleteProject.bind(this)
					}
				}
			}
		});
	},

	onSplashStart: function()
	{
		this.template = wabi.createTemplate("projects");
		this.template.on("click", "#create", this.createProject, this);
		this.template.on("dblclick", "*", this.openProject, this);
		this.template.on("contextmenu", "*", function(event) {
			event.element.select = true;
			editor.plugins.contextmenu.show("projectItem", event.x, event.y);
		});

		editor.offline = true;

		this.data = editor.connection.get("private.projects", this.handleData, this);
		this.template.data = this.data;
		this.template.appendTo(editor.overlayElement);
	},

	onSplashEnd: function() {
		this.template.remove();
	},

	createProject: function(event) {
		this.data.add("Untitled");
	},

	openProject: function(event)
	{
		var data = this.template.get("#projects-list").select.data;
		editor.loadProject(data);
	},

	deleteProject: function(event) 
	{
		var selectedItem = this.template.get("#projects-list").cache.selected;
		if(!selectedItem) { return; }
		
		this.data.remove(selectedItem.data);
	},

	handleData: function(action, key, value, data)
	{
		var loader = this.template.get("#loader");

		if(action === "sync") {
			loader.hidden = true;
		}
		else {
			loader.hidden = true;
		}
	},

	//
	template: null,
	data: null
});

"use strict";

editor.plugin("resources",
{
	create: function()
	{
		this.types =
		{
			texture: {
				ext: [ "png", "jpg", "bmp", "gif" ],
				icon: "fa-delicious"
			},
			sound: {
				ext: [ "mp3", "m4a", "ogg", "wav" ],
				icon: "fa-music"
			},
			video: {
				ext: [ "m4v" ],
				icon: "fa-video-camera"
			},
			text: {
				ext: [ "txt", "json" ],
				icon: "fa-file-text-o"
			},
			folder: {
				ext: [],
				icon: "fa-folder",
				iconOpen: "fa-folder-open",
				content: true
			},
			unknown: {
				ext: [],
				icon: "fa-question"
			}
		};
	},

	addType: function(name, props)
	{
		var type = this.types[name];
		if(type)
		{
			// TODO: Add type safeties!
			console.warn("(plugin.resources.addType) There is already such type added " + type);
		}
		else {
			this.types[name] = props;
		}
	},

	getIconFromExt: function(ext)
	{
		if(!ext) {
			return "fa-question";
		}

		for(var typeName in this.types)
		{
			var type = this.types[typeName];
			var exts = type.ext;
			if(!exts) { continue; }

			for(var n = 0; n < exts.length; n++)
			{
				if(ext === exts[n]) {
					return type.icon ? type.icon : "fa-question";
				}
			}
		}

		return "fa-question";
	},

	getIconFromType: function(name)
	{
		if(!name) {
			return "fa-question";
		}

		var type = this.types[name];

		if(type && type.icon) {
			return type.icon;
		}

		return "fa-question";
	},

	getTypeFromExt: function(extName)
	{
		if(!extName) {
			return null;
		}

		for(var typeName in this.types)
		{
			var type = this.types[typeName];
			var exts = type.ext;
			if(!exts) { continue; }

			for(var n = 0; n < exts.length; n++)
			{
				if(extName === exts[n]) {
					return typeName;
				}
			}
		}

		return null;
	},

	//
	types: null
});

"use strict";

var meta = {
    version: "0.9",
    layer: null,
    layers: {},
    flags: {
        autoPowTwo: true
    },
    time: {
        delta: 0,
        deltaF: 0,
        maxDelta: 250,
        scale: 1,
        curr: 0,
        fps: 0,
        current: 0,
        update: 0,
        accumulator: 0,
        frameIndex: 0,
        updateFreq: 1e3 / 10
    },
    cache: {
        width: 0,
        height: 0,
        timerIndex: 0,
        camera: null,
        uniqueId: 1
    },
    $listeners: {},
    on: function(event, func, owner) {
        var buffer = this.$listeners[event];
        if (!buffer) {
            buffer = [ new this.Watcher(func, owner) ];
            this.$listeners[event] = buffer;
        } else {
            buffer.push(new this.Watcher(func, owner));
        }
    },
    off: function(event, func, owner) {
        var buffer = this.$listeners[event];
        if (!buffer) {
            console.warn("(meta.off) No listeners found for the event: " + event);
            return;
        }
        owner = owner || window;
        var num = buffer.length;
        for (var n = 0; n < num; n++) {
            var watcher = buffer[n];
            if (watcher.owner === owner && watcher.func === func) {
                buffer[n] = buffer[num - 1];
                buffer.pop();
                break;
            }
        }
    },
    emit: function(event, params) {
        var buffer = this.$listeners[event];
        if (!buffer) {
            return;
        }
        if (params) {
            for (var n = 0; n < buffer.length; n++) {
                var item = buffer[n];
                item.func.call(item.owner, params);
            }
        } else {
            for (var n = 0; n < buffer.length; n++) {
                var item = buffer[n];
                item.func.call(item.owner);
            }
        }
    },
    set camera(camera) {
        if (this.cache.camera === camera) {
            return;
        }
        this.cache.camera = camera;
        camera.activate();
    },
    get camera() {
        return this.cache.camera;
    },
    Watcher: function(func, owner) {
        this.func = func;
        this.owner = owner || window;
    }
};

"use strict";

(function(scope) {
    if (!scope.meta) {
        scope.meta = {};
    }
    var initializing = false;
    var fnTest = /\b_super\b/;
    var holders = {};
    meta.class = function(clsName, extendName, prop, cb) {
        if (!initializing) {
            meta.class._construct(clsName, extendName, prop, cb);
        }
    };
    meta.class._construct = function(clsName, extendName, prop, cb) {
        if (!clsName) {
            console.error("(meta.class) Invalid class name");
            return;
        }
        if (!prop) {
            prop = extendName;
            extendName = null;
        }
        if (!prop) {
            prop = {};
        }
        var extend = null;
        if (extendName) {
            var prevScope = null;
            var extendScope = window;
            var extendScopeBuffer = extendName.split(".");
            var num = extendScopeBuffer.length - 1;
            for (var n = 0; n < num; n++) {
                prevScope = extendScope;
                extendScope = extendScope[extendScopeBuffer[n]];
                if (!extendScope) {
                    extendScope = {};
                    prevScope[extendScopeBuffer[n]] = extendScope;
                }
            }
            var name = extendScopeBuffer[num];
            extend = extendScope[name];
            if (!extend) {
                var holder = holders[extendName];
                if (!holder) {
                    holder = new ExtendHolder();
                    holders[extendName] = holder;
                }
                holder.classes.push(new ExtendItem(clsName, prop, cb));
                return;
            }
        }
        Extend(clsName, extend, prop, cb);
    };
    function Extend(clsName, extend, prop, cb) {
        var prevScope = null;
        var scope = window;
        var scopeBuffer = clsName.split(".");
        var num = scopeBuffer.length - 1;
        var name = scopeBuffer[num];
        for (var n = 0; n < num; n++) {
            prevScope = scope;
            scope = scope[scopeBuffer[n]];
            if (!scope) {
                scope = {};
                prevScope[scopeBuffer[n]] = scope;
            }
        }
        var extendHolder = holders[clsName];
        var prevCls = scope[name];
        var cls = function Class(a, b, c, d, e, f) {
            if (!initializing) {
                if (this.init) {
                    this.init(a, b, c, d, e, f);
                }
            }
        };
        var proto = null;
        var extendProto = null;
        if (extend) {
            initializing = true;
            proto = new extend();
            extendProto = proto.__proto__;
            initializing = false;
        } else {
            initializing = true;
            proto = new meta.class();
            initializing = false;
        }
        for (var key in prop) {
            var p = Object.getOwnPropertyDescriptor(prop, key);
            if (p.get || p.set) {
                Object.defineProperty(proto, key, p);
                continue;
            }
            if (extend) {
                if (typeof prop[key] == "function" && typeof extendProto[key] == "function" && fnTest.test(prop[key])) {
                    proto[key] = function(key, fn) {
                        return function(a, b, c, d, e, f) {
                            var tmp = this._super;
                            this._super = extendProto[key];
                            this._fn = fn;
                            var ret = this._fn(a, b, c, d, e, f);
                            this._super = tmp;
                            return ret;
                        };
                    }(key, prop[key]);
                    continue;
                }
            }
            proto[key] = prop[key];
        }
        proto.delete = function() {
            if (this.__managed__) {
                meta.delete(this);
            } else {
                this.remove();
            }
        };
        proto.__managed__ = false;
        cls.prototype = proto;
        cls.prototype.__name__ = clsName;
        cls.prototype.__lastName__ = name;
        cls.prototype.constructor = proto.init || null;
        scope[name] = cls;
        if (prevCls) {
            for (var key in prevCls) {
                cls[key] = prevCls[key];
            }
        }
        if (extendHolder) {
            var extendItem = null;
            var classes = extendHolder.classes;
            num = classes.length;
            for (n = 0; n < num; n++) {
                extendItem = classes[n];
                Extend(extendItem.name, cls, extendItem.prop, extendItem.cb);
            }
            delete holders[clsName];
        }
        if (cb) {
            cb(cls, clsName);
        }
    }
    function ExtendHolder() {
        this.classes = [];
    }
    function ExtendItem(name, prop, cb) {
        this.name = name;
        this.prop = prop;
        this.cb = cb;
    }
    meta.classLoaded = function() {
        var i = 0;
        var holder = null;
        var classes = null;
        var numClasses = 0;
        for (var key in holders) {
            holder = holders[key];
            console.error("Undefined class: " + key);
            classes = holder.classes;
            numClasses = classes.length;
            for (i = 0; i < numClasses; i++) {
                console.error("Undefined class: " + classes[i].name);
            }
        }
        holder = {};
    };
})(typeof window !== void 0 ? window : global);

"use strict";

meta.isPowerOfTwo = function(x) {
    return x != 0 && (x & ~x + 1) === x;
};

meta.getNameFromPath = function(path) {
    var wildcardIndex = path.lastIndexOf(".");
    var slashIndex = path.lastIndexOf("/");
    if (wildcardIndex < 0 || path.length - wildcardIndex > 5) {
        return path.slice(slashIndex + 1);
    }
    return path.slice(slashIndex + 1, wildcardIndex);
};

meta.getExtFromPath = function(path) {
    var wildcardIndex = path.lastIndexOf(".");
    if (wildcardIndex === -1) {
        return null;
    }
    return path.slice(wildcardIndex + 1);
};

meta.genUniqueId = function() {
    return meta.cache.uniqueId++ + "";
};

"use strict";

meta.engine = {
    init: function() {
        meta.emit("init");
        this.parseFlags();
        this.addMetaTags();
        this.createWebGL();
        this.print();
        this.flags |= this.Flag.INITIALIZED;
        this.setup();
    },
    setup: function() {
        meta.camera = new meta.Camera();
        meta.emit("setup");
        this.addListeners();
        var masterLayer = new meta.Layer("master");
        masterLayer.$activate();
        meta.layers.master = masterLayer;
        meta.layer = masterLayer;
        meta.renderer.setup();
        this.updateResolution();
        this.flags |= this.Flag.SETUPED;
        this.preload();
    },
    preload: function() {
        meta.emit("preload");
        this.flags |= this.Flag.PRELOADED;
        var self = this;
        this.$renderLoopFunc = function() {
            self.render();
        };
        this.$renderLoopFunc();
        this.load();
    },
    $renderLoopFunc: null,
    load: function() {
        meta.emit("load");
        this.flags |= this.Flag.LOADED;
    },
    ready: function() {
        meta.emit("ready");
        this.flags |= this.Flag.READY;
    },
    update: function(tDelta) {
        meta.emit("update", tDelta);
    },
    render: function() {
        this.time.frameIndex++;
        var tNow = Date.now();
        if (this.time.pause) {
            this.time.delta = 0;
            this.time.deltaF = 0;
        } else {
            this.time.delta = tNow - this.time.current;
            if (this.time.delta > this.time.maxDelta) {
                this.time.delta = this.time.maxDelta;
            }
            this.time.delta *= this.time.scale;
            this.time.deltaF = this.time.delta / 1e3;
            this.time.accumulator += this.time.delta;
        }
        if (tNow - this.time.fps >= 1e3) {
            this.time.fps = tNow;
            this.fps = this.$fpsCounter;
            this.$fpsCounter = 0;
            meta.emit("fps", this.fps);
        }
        this.update(this.time.deltaF);
        meta.emit("render");
        meta.renderer.render(this.time.deltaF);
        this.$fpsCounter++;
        this.time.current = tNow;
        requestAnimationFrame(this.$renderLoopFunc);
    },
    updateResolution: function() {
        var width = meta.cache.width;
        var height = meta.cache.height;
        if (this.container === document.body) {
            width = window.innerWidth;
            height = window.innerHeight;
        } else {
            width = this.container.clientWidth;
            height = this.container.clientHeight;
        }
        this.width = Math.ceil(width);
        this.height = Math.ceil(height);
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.canvas.style.width = width * this.scaleX + "px";
        this.canvas.style.height = height * this.scaleY + "px";
        meta.renderer.onResize();
        meta.emit("resize", this);
    },
    $updateOffset: function() {
        this.offsetLeft = 0;
        this.offsetTop = 0;
        var element = this.container;
        if (element.offsetParent) {
            do {
                this.offsetLeft += element.offsetLeft;
                this.offsetTop += element.offsetTop;
            } while (element = element.offsetParent);
        }
        var rect = this.container.getBoundingClientRect();
        this.offsetLeft += rect.left;
        this.offsetTop += rect.top;
        rect = this.canvas.getBoundingClientRect();
        this.offsetLeft += rect.left;
        this.offsetTop += rect.top;
    },
    addMetaTags: function() {
        if (this.flags & this.Flag.META_TAGS_ADDED) {
            return;
        }
        var contentType = document.createElement("meta");
        contentType.setAttribute("http-equiv", "Content-Type");
        contentType.setAttribute("content", "text/html; charset=utf-8");
        document.head.appendChild(contentType);
        var encoding = document.createElement("meta");
        encoding.setAttribute("http-equiv", "encoding");
        encoding.setAttribute("content", "utf-8");
        document.head.appendChild(encoding);
        var content = "user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height";
        var viewport = document.createElement("meta");
        viewport.setAttribute("name", "viewport");
        viewport.setAttribute("content", content);
        document.head.appendChild(viewport);
        var appleMobileCapable = document.createElement("meta");
        appleMobileCapable.setAttribute("name", "apple-mobile-web-app-capable");
        appleMobileCapable.setAttribute("content", "yes");
        document.head.appendChild(appleMobileCapable);
        var appleStatusBar = document.createElement("meta");
        appleStatusBar.setAttribute("name", "apple-mobile-web-app-status-bar-style");
        appleStatusBar.setAttribute("content", "black-translucent");
        document.head.appendChild(appleStatusBar);
        this.flags |= this.Flag.META_TAGS_ADDED;
    },
    parseFlags: function() {
        var flag, flagName, flagValue, flagSepIndex;
        var flags = window.location.hash.substr(1).split(",");
        var num = flags.length;
        for (var n = 0; n < num; n++) {
            flag = flags[n];
            flagSepIndex = flag.indexOf("=");
            if (flagSepIndex > 0) {
                flagName = flag.substr(0, flagSepIndex).replace(/ /g, "");
                flagValue = eval(flag.substr(flagSepIndex + 1).replace(/ /g, ""));
                meta.flags[flagName] = flagValue;
            }
        }
    },
    createWebGL: function() {
        this.canvas = document.createElement("canvas");
        this.canvas.id = "meta-webgl";
        this.canvas.style.cssText = this.canvasStyle;
        var params = {
            alpha: false,
            premultipliedAlpha: false
        };
        var context = this.canvas.getContext("webgl", params) || this.canvas.getContext("experimental-webgl", params);
        if (window.WebGLDebugUtils) {
            this.gl = WebGLDebugUtils.makeDebugContext(context);
        } else {
            this.gl = context;
        }
        if (!this.container) {
            this.container = document.body;
        }
        document.body.style.cssText = this.containerStyle;
        this.container.appendChild(this.canvas);
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.depthFunc(this.gl.LEQUAL);
    },
    addListeners: function() {
        var self = this;
        this.cb = {
            resize: function(event) {
                self.updateResolution();
            },
            focus: function(event) {
                self.handleFocus(true);
            },
            blur: function(event) {
                self.handleFocus(false);
            }
        };
        window.addEventListener("resize", this.cb.resize, false);
        window.addEventListener("orientationchange", this.cb.resize, false);
        if (meta.device.hidden) {
            this.cb.visibilityChange = function() {
                self.handleVisibilityChange();
            };
            document.addEventListener(meta.device.visibilityChange, this.cb.visibilityChange);
        }
        window.addEventListener("focus", this.cb.focus);
        window.addEventListener("blur", this.cb.blur);
        if (meta.device.support.fullScreen) {
            this.cb.fullscreen = function() {
                self.onFullScreenChangeCB();
            };
            document.addEventListener(meta.device.fullScreenOnChange, this.cb.fullscreen);
        }
        this.canvas.addEventListener("webglcontextlost", function() {
            self.onCtxLost();
        });
        this.canvas.addEventListener("webglcontextrestored", function() {
            self.onCtxRestored();
        });
    },
    handleFocus: function(value) {
        if (value) {
            this.flags |= this.Flag.FOCUS;
            meta.emit("focus");
        } else {
            this.flags &= ~(this.Flag.FOCUS | this.Flag.PAUSED);
            meta.emit("blur");
        }
    },
    handleVisibilityChange: function() {
        if (document[meta.device.hidden]) {
            this.handleFocus(false);
        } else {
            this.handleFocus(true);
        }
    },
    onFullScreenChangeCB: function() {
        var fullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        meta.device.fullscreen = !!fullscreen;
        this.onFullscreen.emit(meta.device.fullscreen, meta.Event.FULLSCREEN);
    },
    onCtxLost: function() {
        console.log("(Context lost)");
    },
    onCtxRestored: function() {
        console.log("(Context restored)");
    },
    print: function() {
        if (meta.device.support.consoleCSS) {
            console.log("%c META2D v" + meta.version + " ", "background: #000; color: white; font-size: 12px; padding: 2px 0 1px 0;", "http://meta2d.com");
            console.log("%cBrowser: %c" + meta.device.name + " " + meta.device.version + "	", "font-weight: bold; padding: 2px 0 1px 0;", "padding: 2px 0 1px 0;");
            console.log("%cRenderer: %cCanvas ", "font-weight: bold; padding: 2px 0 2px 0;", "padding: 2px 0 2px 0;");
        } else {
            console.log("META2D v" + meta.version + " http://meta2d.com ");
            console.log("Browser: " + meta.device.name + " " + meta.device.version + "	");
            console.log("Renderer: Canvas ");
        }
    },
    get focus() {
        return this.flags & this.Flag.FOCUS;
    },
    Flag: {
        INITIALIZED: 1 << 0,
        SETUPED: 1 << 1,
        PRELOADED: 1 << 2,
        LOADED: 1 << 3,
        READY: 1 << 4,
        META_TAGS_ADDED: 1 << 5,
        FOCUS: 1 << 6,
        FULLSCREEN: 1 << 7
    },
    container: null,
    canvas: null,
    gl: null,
    flags: null,
    cb: null,
    timers: [],
    timersRemove: [],
    width: 0,
    height: 0,
    scaleX: 1,
    scaleY: 1,
    zoom: 1,
    ratio: 1,
    offsetLeft: 0,
    offsetTop: 0,
    time: meta.time,
    fps: 0,
    $fpsCounter: 0,
    containerStyle: "padding:0; margin:0;",
    canvasStyle: "position:absolute; width: 100%; height: 100%; overflow:hidden; translateZ(0); " + "-webkit-backface-visibility:hidden; -webkit-perspective: 1000; " + "-webkit-touch-callout: none; -webkit-user-select: none; zoom: 1;"
};

"use strict";

meta.cache.exts = {};

meta.cache.extParams = {};

meta.getExt = function(name) {
    var extension = this.cache.exts[name];
    if (extension) {
        return extension;
    }
    var gl = meta.engine.gl;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture");
        break;

      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic");
        break;

      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc");
        break;

      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;

      case "WEBGL_compressed_texture_etc1":
        extension = gl.getExtension("WEBGL_compressed_texture_etc1");
        break;

      default:
        extension = gl.getExtension(name);
        break;
    }
    if (extension === null) {
        console.warn("(meta.getExtension) Extension not supported: " + name);
        return;
    }
    this.cache.exts[name] = extension;
    return extension;
};

meta.getExtParam = function(type) {
    var param = this.cache.extParams[type];
    if (!param) {
        param = meta.engine.gl.getParameter(type);
        this.cache.extParams[type] = param;
    }
    return param;
};

"use strict";

meta.device = {
    load: function() {
        this.checkBrowser();
        this.mobile = this.isMobileAgent();
        this.checkConsoleCSS();
        this.checkFileAPI();
        this.support.onloadedmetadata = typeof window.onloadedmetadata === "object";
        this.support.onkeyup = typeof window.onkeyup === "object";
        this.support.onkeydown = typeof window.onkeydown === "object";
        this.support.canvas = this.isCanvasSupport();
        this.support.webgl = this.isWebGLSupport();
        this.modernize();
    },
    checkBrowser: function() {
        var regexps = {
            Chrome: [ /Chrome\/(\S+)/ ],
            Firefox: [ /Firefox\/(\S+)/ ],
            MSIE: [ /MSIE (\S+);/ ],
            Opera: [ /OPR\/(\S+)/, /Opera\/.*?Version\/(\S+)/, /Opera\/(\S+)/ ],
            Safari: [ /Version\/(\S+).*?Safari\// ]
        };
        var userAgent = navigator.userAgent;
        var name, currRegexp, match;
        var numElements = 2;
        for (name in regexps) {
            while (currRegexp = regexps[name].shift()) {
                if (match = userAgent.match(currRegexp)) {
                    this.version = match[1].match(new RegExp("[^.]+(?:.[^.]+){0," + --numElements + "}"))[0];
                    this.name = name;
                    this.versionBuffer = this.version.split(".");
                    var versionBufferLength = this.versionBuffer.length;
                    for (var i = 0; i < versionBufferLength; i++) {
                        this.versionBuffer[i] = parseInt(this.versionBuffer[i]);
                    }
                    break;
                }
            }
        }
        if (this.versionBuffer === null || this.name === "unknown") {
            console.warn("(meta.device.checkBrowser) Could not detect browser.");
        } else {
            if (this.name === "Chrome" || this.name === "Safari" || this.name === "Opera") {
                this.vendor = "webkit";
            } else if (this.name === "Firefox") {
                this.vendor = "moz";
            } else if (this.name === "MSIE") {
                this.vendor = "ms";
            }
        }
    },
    checkConsoleCSS: function() {
        if (!this.mobile && (this.name === "Chrome" || this.name === "Opera")) {
            this.support.consoleCSS = true;
        } else {
            this.support.consoleCSS = false;
        }
    },
    checkFileAPI: function() {
        if (window.File && window.FileReader && window.FileList && window.Blob) {
            this.support.fileAPI = true;
        } else {
            this.support.fileAPI = false;
        }
    },
    modernize: function() {
        if (!Number.MAX_SAFE_INTEGER) {
            Number.MAX_SAFE_INTEGER = 9007199254740991;
        }
        this.supportConsole();
        this.supportPageVisibility();
        this.supportFullScreen();
        this.supportRequestAnimFrame();
        this.supportPerformanceNow();
        this.supportAudioFormats();
        this.supportAudioAPI();
        this.supportFileSystemAPI();
    },
    isMobileAgent: function() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    },
    isCanvasSupport: function() {
        return !!window.CanvasRenderingContext2D;
    },
    isWebGLSupport: function() {
        var canvas = document.createElement("canvas");
        var context = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        return !!context;
    },
    supportConsole: function() {
        if (!window.console) {
            window.console = {};
            window.console.log = meta.emptyFuncParam;
            window.console.warn = meta.emptyFuncParam;
            window.console.error = meta.emptyFuncParam;
        }
    },
    supportPageVisibility: function() {
        if (document.hidden !== undefined) {
            this.hidden = "hidden";
            this.visibilityChange = "visibilitychange";
        } else if (document.hidden !== undefined) {
            this.hidden = "webkitHidden";
            this.visibilityChange = "webkitvisibilitychange";
        } else if (document.hidden !== undefined) {
            this.hidden = "mozhidden";
            this.visibilityChange = "mozvisibilitychange";
        } else if (document.hidden !== undefined) {
            this.hidden = "mshidden";
            this.visibilityChange = "msvisibilitychange";
        }
    },
    supportFullScreen: function() {
        this.$fullScreenRequest();
        this.$fullScreenExit();
        this.$fullScreenOnChange();
        this.support.fullScreen = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled;
    },
    $fullScreenRequest: function() {
        var element = document.documentElement;
        if (element.requestFullscreen !== undefined) {
            this.fullScreenRequest = "requestFullscreen";
        } else if (element.webkitRequestFullscreen !== undefined) {
            this.fullScreenRequest = "webkitRequestFullscreen";
        } else if (element.mozRequestFullScreen !== undefined) {
            this.fullScreenRequest = "mozRequestFullScreen";
        } else if (element.msRequestFullscreen !== undefined) {
            this.fullScreenRequest = "msRequestFullscreen";
        }
    },
    $fullScreenExit: function() {
        if (document.exitFullscreen !== undefined) {
            this.fullScreenExit = "exitFullscreen";
        } else if (document.webkitExitFullscreen !== undefined) {
            this.fullScreenExit = "webkitExitFullscreen";
        } else if (document.mozCancelFullScreen !== undefined) {
            this.fullScreenExit = "mozCancelFullScreen";
        } else if (document.msExitFullscreen !== undefined) {
            this.fullScreenExit = "msExitFullscreen";
        }
    },
    $fullScreenOnChange: function() {
        if (document.onfullscreenchange !== undefined) {
            this.fullScreenOnChange = "fullscreenchange";
        } else if (document.onwebkitfullscreenchange !== undefined) {
            this.fullScreenOnChange = "webkitfullscreenchange";
        } else if (document.onmozfullscreenchange !== undefined) {
            this.fullScreenOnChange = "mozfullscreenchange";
        } else if (document.onmsfullscreenchange !== undefined) {
            this.fullScreenOnChange = "msfullscreenchange";
        }
    },
    supportRequestAnimFrame: function() {
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function() {
                return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
                    window.setTimeout(callback, 1e3 / 60);
                };
            }();
        }
    },
    supportPerformanceNow: function() {
        if (window.performance === undefined) {
            window.performance = {};
        }
        if (window.performance.now === undefined) {
            window.performance.now = Date.now;
        }
    },
    supportAudioFormats: function() {
        var audio = document.createElement("audio");
        if (audio.canPlayType("audio/mp4")) {
            this.audioFormats.push("m4a");
        }
        if (audio.canPlayType("audio/ogg")) {
            this.audioFormats.push("ogg");
        }
        if (audio.canPlayType("audio/mpeg")) {
            this.audioFormats.push("mp3");
        }
        if (audio.canPlayType("audio/wav")) {
            this.audioFormats.push("wav");
        }
    },
    supportAudioAPI: function() {
        if (!window.AudioContext) {
            window.AudioContext = window.webkitAudioContext || window.mozAudioContext || window.oAudioContext || window.msAudioContext;
        }
        if (window.AudioContext) {
            this.audioAPI = true;
        }
    },
    supportFileSystemAPI: function() {
        if (!window.requestFileSystem) {
            window.requestFileSystem = window.webkitRequestFileSystem || window.mozRequestFileSystem || window.oRequestFileSystem || window.msRequestFileSystem;
        }
        if (window.requestFileSystem) {
            this.support.fileSystemAPI = true;
        }
    },
    name: "unknown",
    version: "0",
    versionBuffer: null,
    vendors: [ "", "webkit", "moz", "ms", "o" ],
    vendor: "",
    support: {},
    audioFormats: [],
    mobile: false,
    isPortrait: false,
    audioAPI: false,
    hidden: null,
    visibilityChange: null,
    fullScreenRequest: null,
    fullScreenExit: null,
    fullScreenOnChange: null,
    fullscreen: false
};

meta.device.load();

"use strict";

meta.input = {
    setup: function() {
        var numTotalKeys = this.$numKeys + this.$numInputs + 1;
        this.keys = new Array(numTotalKeys);
        this.keybinds = new Array(numTotalKeys);
        this.$eventDown = new this.Event();
        this.$event = new this.Event();
        meta.on("blur", this.resetInputs, this);
        meta.on("update", this.updatePicking, this);
        this.$loadIgnoreKeys();
        this.$addEventListeners();
    },
    updatePicking: function(tDelta) {},
    handleKeyDown: function(domEvent) {
        var keyCode = domEvent.keyCode;
        this.checkIgnoreKey(domEvent, keyCode);
        if (!this.enable) {
            return;
        }
        if (this.stickyKeys && this.keys[keyCode]) {
            return;
        }
        this.keys[keyCode] = 1;
        this.$eventDown.domEvent = domEvent;
        this.$eventDown.prevScreenX = 0;
        this.$eventDown.prevScreenY = 0;
        this.$eventDown.screenX = 0;
        this.$eventDown.screenY = 0;
        this.$eventDown.x = 0;
        this.$eventDown.y = 0;
        this.$eventDown.delta = 0;
        this.$eventDown.keyCode = keyCode;
        this.$eventDown.keybind = this.keybinds[keyCode] || null;
        meta.emit("input-down", this.$eventDown);
        this.updateRepeatKey(keyCode);
    },
    handleKeyUp: function(domEvent) {
        var keyCode = event.keyCode;
        this.checkIgnoreKey(domEvent, keyCode);
        if (!this.enable) {
            return;
        }
        this.keys[keyCode] = 0;
        this.$event.domEvent = domEvent;
        this.$event.prevScreenX = 0;
        this.$event.prevScreenY = 0;
        this.$event.screenX = 0;
        this.$event.screenY = 0;
        this.$event.x = 0;
        this.$event.y = 0;
        this.$event.delta = 0;
        this.$event.keyCode = keyCode;
        this.$event.keybind = this.keybinds[keyCode] || null;
        meta.emit("input-up", this.$event);
        if (this.repeatKey && this.$repeatTimer) {
            this.$repeatTimer.stop();
        }
    },
    handleMouseDown: function(domEvent) {
        if (!this.enable) {
            return;
        }
        var keyCode = event.button + this.BUTTON_ENUM_OFFSET;
        this.keys[keyCode] = 1;
        var engine = meta.engine;
        var camera = meta.camera;
        this.prevScreenX = this.screenX;
        this.prevScreenY = this.screenX;
        this.screenX = (event.pageX - engine.offsetLeft) * engine.scaleX * engine.ratio;
        this.screenY = (event.pageY - engine.offsetTop) * engine.scaleY * engine.ratio;
        this.x = this.screenX * camera.zoomRatio + camera.volume.x | 0;
        this.y = this.screenY * camera.zoomRatio + camera.volume.y | 0;
        this.$event.domEvent = domEvent;
        this.$event.prevScreenX = this.prevScreenX;
        this.$event.prevScreenY = this.prevScreenY;
        this.$event.screenX = this.screenX;
        this.$event.screenY = this.screenY;
        this.$event.x = this.x;
        this.$event.y = this.y;
        this.$event.delta = 0;
        this.$event.keyCode = keyCode;
        this.$event.keybind = this.keybinds[keyCode] || null;
        meta.emit("input-down", this.$event);
    },
    handleMouseUp: function(domEvent) {
        if (!this.enable) {
            return;
        }
        var keyCode = event.button + this.BUTTON_ENUM_OFFSET;
        this.keys[keyCode] = 0;
        var engine = meta.engine;
        var camera = meta.camera;
        this.prevScreenX = this.screenX;
        this.prevScreenY = this.screenY;
        this.screenX = (event.pageX - engine.offsetLeft) * engine.scaleX * engine.ratio;
        this.screenY = (event.pageY - engine.offsetTop) * engine.scaleY * engine.ratio;
        this.x = this.screenX * camera.zoomRatio + camera.volume.x | 0;
        this.y = this.screenY * camera.zoomRatio + camera.volume.y | 0;
        this.$event.domEvent = domEvent;
        this.$event.prevScreenX = this.prevScreenX;
        this.$event.prevScreenY = this.prevScreenY;
        this.$event.screenX = this.screenX;
        this.$event.screenY = this.screenY;
        this.$event.x = this.x;
        this.$event.y = this.y;
        this.$event.delta = 0;
        this.$event.keyCode = keyCode;
        this.$event.keybind = this.keybinds[keyCode] || null;
        meta.emit("input-up", this.$event);
    },
    handleMouseMove: function(domEvent) {
        if (document.activeElement === document.body) {
            domEvent.preventDefault();
        }
        if (!this.enable) {
            return;
        }
        var engine = meta.engine;
        var camera = meta.camera;
        this.prevScreenX = this.screenX;
        this.prevScreenY = this.screenY;
        this.screenX = (event.pageX - engine.offsetLeft) * engine.scaleX * engine.ratio;
        this.screenY = (event.pageY - engine.offsetTop) * engine.scaleY * engine.ratio;
        this.x = this.screenX * camera.zoomRatio + camera.volume.x | 0;
        this.y = this.screenY * camera.zoomRatio + camera.volume.y | 0;
        this.$event.domEvent = domEvent;
        this.$event.prevScreenX = this.prevScreenX;
        this.$event.prevScreenY = this.prevScreenY;
        this.$event.screenX = this.screenX;
        this.$event.screenY = this.screenY;
        this.$event.x = this.x;
        this.$event.y = this.y;
        this.$event.delta = 0;
        this.$event.keyCode = -1;
        meta.emit("input-move", this.$event);
    },
    handleMouseDbClick: function(domEvent) {
        if (!this.enable) {
            return;
        }
        var engine = meta.engine;
        var camera = meta.camera;
        var keyCode = domEvent.button;
        this.prevScreenX = this.screenX;
        this.prevScreenY = this.screenY;
        this.screenX = (event.pageX - engine.offsetLeft) * engine.scaleX * engine.ratio;
        this.screenY = (event.pageY - engine.offsetTop) * engine.scaleY * engine.ratio;
        this.x = this.screenX * camera.zoomRatio + camera.volume.x | 0;
        this.y = this.screenY * camera.zoomRatio + camera.volume.y | 0;
        this.$event.domEvent = domEvent;
        this.$event.prevScreenX = this.prevScreenX;
        this.$event.prevScreenY = this.prevScreenY;
        this.$event.screenX = this.screenX;
        this.$event.screenY = this.screenY;
        this.$event.x = this.x;
        this.$event.y = this.y;
        this.$event.delta = 0;
        this.$event.keyCode = keyCode;
        this.$event.keybind = this.keybinds[keyCode] || null;
        meta.emit("input-up", this.$event);
    },
    handleTouchDown: function(domEvent) {
        if (document.activeElement === document.body) {
            domEvent.preventDefault();
        }
        var engine = meta.engine;
        var camera = meta.camera;
        var changedTouches = domEvent.changedTouches;
        var numTouches = changedTouches.length;
        for (var i = 0; i < numTouches; i++) {
            var id = this.touches.length - 1;
            var touch = changedTouches[i];
            this.touches.push(touch.identifier);
            var screenX = (touch.pageX - engine.offsetLeft) * engine.scaleX * engine.ratio;
            var screenY = (touch.pageY - engine.offsetTop) * engine.scaleY * engine.ratio;
            var x = screenX * camera.zoomRatio + camera.volume.x | 0;
            var y = screenY * camera.zoomRatio + camera.volume.y | 0;
            var keyCode = id + this.BUTTON_ENUM_OFFSET;
            this.keys[keyCode] = 1;
            this.$event.domEvent = domEvent;
            this.$event.prevScreenX = screenX;
            this.$event.prevScreenY = screenY;
            this.$event.screenX = screenX;
            this.$event.screenY = screenY;
            this.$event.x = x;
            this.$event.y = y;
            this.$event.delta = 0;
            this.$event.keyCode = keyCode;
            this.$event.keybind = this.keybinds[keyCode] || null;
            if (id === 0) {
                this.screenX = screenX;
                this.screenY = screenY;
                this.x = x;
                this.y = y;
            }
            meta.emit("input-down", this.$event);
        }
    },
    handleTouchUp: function(domEvent) {
        if (document.activeElement === document.body) {
            domEvent.preventDefault();
        }
        var engine = meta.engine;
        var camera = meta.camera;
        var changedTouches = domEvent.changedTouches;
        var numTouches = changedTouches.length;
        for (var i = 0; i < numTouches; i++) {
            var touch = changedTouches[i];
            var id = this.$getTouchID(touch.identifier);
            if (id === -1) {
                continue;
            }
            this.touches.splice(id, 1);
            var screenX = (touch.pageX - engine.offsetLeft) * engine.scaleX * engine.ratio;
            var screenY = (touch.pageY - engine.offsetTop) * engine.scaleY * engine.ratio;
            var x = screenX * camera.zoomRatio + camera.volume.x | 0;
            var y = screenY * camera.zoomRatio + camera.volume.y | 0;
            var keyCode = id + this.BUTTON_ENUM_OFFSET;
            this.keys[keyCode] = 0;
            if (id === 0) {
                this.prevScreenX = this.screenX;
                this.prevScreenY = this.screenY;
                this.screenX = screenX;
                this.screenY = screenY;
                this.x = x;
                this.y = y;
                this.$event.prevScreenX = this.prevScreenX;
                this.$event.prevScreenY = this.prevScreenY;
            } else {
                this.$event.prevScreenX = 0;
                this.$event.prevScreenY = 0;
            }
            this.$event.domEvent = domEvent;
            this.$event.screenX = screenX;
            this.$event.screenY = screenY;
            this.$event.x = x;
            this.$event.y = y;
            this.$event.delta = 0;
            this.$event.keyCode = id;
            this.$event.keybind = this.keybinds[keyCode] || null;
            meta.emit("input-down", this.$event);
        }
    },
    handleTouchMove: function(domEvent) {
        if (document.activeElement === document.body) {
            domEvent.preventDefault();
        }
        var scope = meta;
        var camera = scope.camera;
        var changedTouches = domEvent.changedTouches;
        var numTouches = changedTouches.length;
        for (var i = 0; i < numTouches; i++) {
            var touch = changedTouches[i];
            var id = this.$getTouchID(touch.identifier);
            if (id === -1) {
                continue;
            }
            var screenX = (touch.pageX - engine.offsetLeft) * engine.scaleX * engine.ratio;
            var screenY = (touch.pageY - engine.offsetTop) * engine.scaleY * engine.ratio;
            var x = screenX * camera.zoomRatio + camera.volume.x | 0;
            var y = screenY * camera.zoomRatio + camera.volume.y | 0;
            var keyCode = id + this.BUTTON_ENUM_OFFSET;
            if (id === 0) {
                this.prevScreenX = this.screenX;
                this.prevScreenY = this.screenY;
                this.screenX = screenX;
                this.screenY = screenY;
                this.x = x;
                this.y = y;
                this.$event.prevScreenX = this.prevScreenX;
                this.$event.prevScreenY = this.prevScreenY;
            } else {
                this.$event.prevScreenX = screenX;
                this.$event.prevScreenY = screenY;
            }
            this.$event.domEvent = domEvent;
            this.$event.screenX = 0;
            this.$event.screenY = 0;
            this.$event.x = x;
            this.$event.y = y;
            this.$event.delta = 0;
            this.$event.keyCode = keyCode;
            this.$event.keybind = this.keybinds[keyCode] || null;
            meta.emit("input-move", $event);
        }
    },
    handleMouseWheel: function(domEvent) {
        if (document.activeElement === document.body) {
            domEvent.preventDefault();
        }
        var delta = Math.max(-1, Math.min(1, domEvent.wheelDelta || -domEvent.detail));
        var engine = meta.engine;
        var camera = meta.camera;
        this.prevScreenX = this.screenX;
        this.prevScreenY = this.screenY;
        this.screenX = (event.pageX - engine.offsetLeft) * engine.scaleX * engine.ratio;
        this.screenY = (event.pageY - engine.offsetTop) * engine.scaleY * engine.ratio;
        this.x = this.screenX * camera.zoomRatio + camera.volume.x | 0;
        this.y = this.screenY * camera.zoomRatio + camera.volume.y | 0;
        this.$event.domEvent = domEvent;
        this.$event.prevScreenX = this.prevScreenX;
        this.$event.prevScreenY = this.prevScreenY;
        this.$event.screenX = this.screenX;
        this.$event.screenY = this.screenY;
        this.$event.x = this.x;
        this.$event.y = this.y;
        this.$event.delta = delta;
        this.$event.keyCode = 0;
        this.$event.keybind = null;
        meta.emit("input-scroll", this.$event);
    },
    $getTouchID: function(eventTouchID) {
        for (var n = 0; n < this.touches.length; n++) {
            if (this.touches[n] === eventTouchID) {
                return n;
            }
        }
        return -1;
    },
    resetInputs: function() {
        this.$event.domEvent = null;
        this.$event.prevScreenX = this.prevScreenX;
        this.$event.prevScreenY = this.prevScreenY;
        this.$event.screenX = this.screenX;
        this.$event.screenY = this.screenY;
        this.$event.x = this.x;
        this.$event.y = this.y;
        this.$event.delta = 0;
        for (var n = 0; n < this.keys.length; n++) {
            if (!this.keys[n]) {
                continue;
            }
            this.keys[n] = 0;
            this.$event.keyCode = n;
            this.$event.keybind = this.keybinds[n];
            meta.emit("input-up", this.$event);
        }
        for (var n = 0; n < this.touches.length; n++) {
            if (!this.touches[n]) {
                continue;
            }
            var keyCode = n + this.BUTTON_ENUM_OFFSET;
            this.$event.keyCode = keyCode;
            this.$event.keybind = this.keybinds[keyCode];
        }
        this.$eventDown = new this.Event();
        this.$event = new this.Event();
    },
    keybind: function(keybind, keys) {
        if (keys instanceof Array) {
            for (var n = 0; n < keys.length; n++) {
                var key = keys[n];
                this.keybinds[key] = keybind;
                this.keybindMap[keybind] = key;
            }
        } else {
            this.keybinds[keys] = keybind;
            this.keybindMap[keybind] = keys;
        }
    },
    isDown: function(key) {
        return this.keys[key];
    },
    isUp: function(key) {
        return !this.keys[key];
    },
    isKeybindDown: function(keybind) {
        return this.keys[this.keybindMap[keybind]];
    },
    isKeybindUp: function(keybind) {
        return !this.keys[this.keybindMap[keybind]];
    },
    checkIgnoreKey: function(domEvent, keyCode) {
        if (document.activeElement === document.body) {
            if (window.top && this.iframeKeys[keyCode]) {
                domEvent.preventDefault();
            }
            if (this.cmdKeys[keyCode] !== undefined) {
                this.numCmdKeysPressed++;
            }
            if (this.ignoreKeys[keyCode] !== undefined && this.numCmdKeysPressed <= 0) {
                domEvent.preventDefault();
            }
        }
    },
    updateRepeatKey: function(keyCode) {
        if (!this.repeatKey) {
            return;
        }
        if (!this.$repeatTimer) {
            this.$repeatTimer = meta.addTimer(this, this.repeatFunc, this.repeatDelay);
        }
        this.repeatKey = keyCode;
        this.$repeatTimer.reset();
    },
    repeatFunc: function() {
        this.$eventDown.domEvent = domEvent;
        this.$eventDown.prevScreenX = 0;
        this.$eventDown.prevScreenY = 0;
        this.$eventDown.screenX = 0;
        this.$eventDown.screenY = 0;
        this.$eventDown.x = 0;
        this.$eventDown.y = 0;
        this.$eventDown.delta = 0;
        this.$eventDown.keyCode = keyCode;
        this.$eventDown.keybind = this.keybinds[keyCode] || null;
        meta.emit("input-down", $this.eventDown);
    },
    $addEventListeners: function() {
        var self = this;
        window.addEventListener("mousedown", function(event) {
            self.handleMouseDown(event);
        });
        window.addEventListener("mouseup", function(event) {
            self.handleMouseUp(event);
        });
        window.addEventListener("mousemove", function(event) {
            self.handleMouseMove(event);
        });
        window.addEventListener("dblclick", function(event) {
            self.handleMouseDbClick(event);
        });
        window.addEventListener("touchstart", function(event) {
            self.handleTouchDown(event);
        });
        window.addEventListener("touchend", function(event) {
            self.handleTouchUp(event);
        });
        window.addEventListener("touchmove", function(event) {
            self.handleTouchMove(event);
        });
        window.addEventListener("touchcancel", function(event) {
            self.handleTouchUp(event);
        });
        window.addEventListener("touchleave", function(event) {
            self.handleTouchUp(event);
        });
        window.addEventListener("mousewheel", function(event) {
            self.handleMouseWheel(event);
        });
        if (meta.device.support.onkeydown) {
            window.addEventListener("keydown", function(event) {
                self.handleKeyDown(event);
            });
        }
        if (meta.device.support.onkeyup) {
            window.addEventListener("keyup", function(event) {
                self.handleKeyUp(event);
            });
        }
    },
    $loadIgnoreKeys: function() {
        this.ignoreKeys = {};
        this.ignoreKeys[8] = 1;
        this.ignoreKeys[9] = 1;
        this.ignoreKeys[13] = 1;
        this.ignoreKeys[17] = 1;
        this.ignoreKeys[91] = 1;
        this.ignoreKeys[38] = 1;
        this.ignoreKeys[39] = 1;
        this.ignoreKeys[40] = 1;
        this.ignoreKeys[37] = 1;
        this.ignoreKeys[124] = 1;
        this.ignoreKeys[125] = 1;
        this.ignoreKeys[126] = 1;
        this.cmdKeys[91] = 1;
        this.cmdKeys[17] = 1;
        this.iframeKeys[37] = 1;
        this.iframeKeys[38] = 1;
        this.iframeKeys[39] = 1;
        this.iframeKeys[40] = 1;
    },
    ignoreFKeys: function(value) {
        this.ignoreKeys[112] = value;
        this.ignoreKeys[113] = value;
        this.ignoreKeys[114] = value;
        this.ignoreKeys[115] = value;
        this.ignoreKeys[116] = value;
        this.ignoreKeys[117] = value;
        this.ignoreKeys[118] = value;
        this.ignoreKeys[119] = value;
        this.ignoreKeys[120] = value;
        this.ignoreKeys[121] = value;
        this.ignoreKeys[122] = value;
        this.ignoreKeys[123] = value;
    },
    set ignoreFKeys(flag) {
        if (flag) {
            this.$ignoreFKeys(1);
        } else {
            this.$ignoreFKeys(0);
        }
    },
    get ignoreFKeys() {
        return !!this.$ignoreKeys[112];
    },
    Event: function() {
        this.domEvent = null;
        this.x = 0;
        this.y = 0;
        this.delta = 0;
        this.prevScreenX = 0;
        this.prevScreenY = 0;
        this.screenX = 0;
        this.screenY = 0;
        this.keyCode = 0;
        this.keybind = null;
        this.entity = null;
    },
    keys: null,
    keybinds: null,
    touches: [],
    keybindMap: {},
    ignoreKeys: {},
    cmdKeys: {},
    iframeKeys: {},
    enable: true,
    stickyKeys: false,
    numCmdKeysPressed: 0,
    $repeatTimer: null,
    repeatKey: false,
    repeatDelay: 200,
    x: 0,
    y: 0,
    screenX: 0,
    screenY: 0,
    prevScreenX: 0,
    prevScreenY: 0,
    $numKeys: 256,
    $numInputs: 10,
    BUTTON_ENUM_OFFSET: 2e3,
    entitiesPicking: [],
    entitiesPickingRemove: []
};

meta.key = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    ESC: 27,
    SPACE: 32,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    DELETE: 46,
    NUM_0: 48,
    NUM_1: 49,
    NUM_2: 50,
    NUM_3: 51,
    NUM_4: 52,
    NUM_5: 53,
    NUM_6: 54,
    NUM_7: 55,
    NUM_8: 56,
    NUM_9: 57,
    NUMPAD_0: 96,
    NUMPAD_1: 97,
    NUMPAD_2: 98,
    NUMPAD_3: 99,
    NUMPAD_4: 100,
    NUMPAD_5: 101,
    NUMPAD_6: 102,
    NUMPAD_7: 103,
    NUMPAD_8: 104,
    NUMPAD_9: 105,
    MULTIPLY: 106,
    ADD: 107,
    SUBTRACT: 109,
    DECIMAL: 110,
    DIVIDE: 111,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    SQUARE_BRACKET_LEFT: 91,
    SQUARE_BRACKET_RIGHT: 91,
    PARENTHESES_LEFT: 91,
    PARENTHESES_RIGHT: 91,
    BRACES_LEFT: 91,
    BRACES_RIGHT: 92,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    PLUS: 187,
    MINUS: 189,
    TILDE: 192,
    APOSTROPHE: 222,
    BUTTON_LEFT: 0 + meta.input.BUTTON_ENUM_OFFSET,
    BUTTON_MIDDLE: 1 + meta.input.BUTTON_ENUM_OFFSET,
    BUTTON_RIGHT: 2 + meta.input.BUTTON_ENUM_OFFSET
};

meta.input.setup();

"use strict";

meta.pools = {};

meta.new = function(cls, a, b) {
    if (!cls) {
        console.warn("(meta.new) Invalid class passed");
        return;
    }
    var buffer = meta.pools[cls.prototype.__name__];
    if (!buffer) {
        buffer = [];
        meta.pools[cls.prototype.__name__] = buffer;
    }
    var obj = buffer.pop();
    if (!obj) {
        obj = new cls(a, b);
    } else {
        obj.create(a, b);
    }
    return obj;
};

meta.delete = function(obj) {
    if (!obj) {
        console.warn("(meta.delete) Invalid object passed");
        return;
    }
    var buffer = meta.pools[obj.__name__];
    if (!buffer) {
        console.warn("(meta.delete) Buffer not found for: " + obj.__name__);
        return;
    }
    obj.remove();
    buffer.push(obj);
};

"use strict";

meta.Layer = function(id) {
    this.id = id;
    this.flags = 0;
    this.entities = [];
    this.entitiesRemove = [];
    this.children = {};
    this.$position = new meta.Vector2(0, 0);
    this.$z = 0;
};

meta.Layer.prototype = {
    add: function(entity) {
        if (entity.$layer) {
            if (entity.$layer === this) {
                console.warn("(meta.Layer.add) Entity is already added to this layer");
            } else {
                console.warn("(meta.Layer.add) Entity is already added to some other layer");
            }
            return;
        }
        entity.flags |= entity.Flag.ROOT;
        entity.$setLayer(this);
        if (this.$position.x !== 0 || this.$position.y !== 0) {
            entity.updatePosition();
        }
        if (this.$z !== 0) {
            entity.updateZ();
        }
        this.entities.push(entity);
        this.$addChildren(entity.children);
        if (this.flags & this.Flag.ACTIVE && !(this.flags & this.Flag.INSTANCE_HIDDEN)) {
            meta.renderer.addEntity(entity, false);
        }
    },
    $addChildren: function(children) {},
    remove: function(entity) {
        if (entity instanceof meta.Sprite) {
            if (entity.$layer !== this) {
                console.warn("(meta.Layer.remove) Entity has different layer: ", entity.$layer.id);
                return;
            }
            var index = this.entities.indexOf(entity);
            if (index === -1) {
                console.warn("(meta.Layer.remove) Entity not found: ", entity.id);
                return;
            }
            this.entitiesRemove.push(entity);
        } else if (typeof entity === "string") {
            if (entity.$layer !== this) {
                console.warn("(meta.Layer.remove) Entity has different layer: ", entity.$layer.id);
                return;
            }
        } else {
            return console.warn("(meta.Layer.remove) Invalid entity or id passed");
        }
        meta.renderer.removeEntity(entity);
    },
    attach: function(layer) {
        if (!layer) {
            return console.warn("(meta.Layer.attach) Invalid layer passed");
        }
        if (layer.parent) {
            if (layer.parent === this) {
                return;
            }
            layer.detach();
            layer.attach(this);
        }
        this.children[layer.id] = layer;
        if (this.flags & this.Flag.ACTIVE) {
            layer.$activate();
        }
    },
    detach: function(layer) {
        if (!layer) {
            if (!layer.parent) {
                return console.warn("(meta.Layer.detach) Layer does not have parent: ", layer);
            }
            layer.parent.detach(this);
            return;
        }
        if (layer.parent !== this) {
            return console.warn("(meta.Layer.detach) Layer `" + layer.id + "` has not been attached to parent `" + this.id + "`");
        }
        if (!this.children[layer.id]) {
            return console.error(" (logic error) (meta.Layer.detach) Layer `" + layer.id + "` has not been attached to parent `" + this.id + "`");
        }
        delete this.children[layer.id];
        if (this.flags & this.Flag.ACTIVE) {
            layer.$deactivate();
        }
    },
    $activate: function() {
        this.flags |= this.Flag.ACTIVE;
        if (this.flags & this.Flag.INSTANCE_HIDDEN) {
            return;
        }
        meta.renderer.addEntities(this.entities);
        if (this.children) {
            var num = this.children.length;
            for (var n = 0; n < num; n++) {
                this.children[n].$activate();
            }
        }
    },
    $deactivate: function() {
        this.flags &= ~this.Flag.ACTIVE;
        if (this.flags & this.Flag.INSTANCE_HIDDEN) {
            return;
        }
        meta.renderer.removeEntities(this.entities);
        if (this.children) {
            var num = this.children.length;
            for (var n = 0; n < num; n++) {
                this.children[n].$deactivate();
            }
        }
    },
    get active() {
        return (this.flags & this.Flag.ACTIVE) === this.Flag.ACTIVE;
    },
    set fixed(value) {
        if (value) {
            if (this.flags & this.Flag.FIXED) {
                return;
            }
            this.flags |= this.Flag.FIXED;
            if (this.flags & this.Flag.ACTIVE) {
                meta.renderer.needRender = true;
            }
        } else {
            if ((this.flags & this.Flag.FIXED) === 0) {
                return;
            }
        }
        this.updateFixed();
    },
    get fixed() {
        return (this.flags & this.Flag.FIXED) === this.Flag.FIXED;
    },
    updateFixed: function() {
        if (this.parent) {
            if (this.flags & this.Flag.FIXED && this.parent.flags & this.Flag.INSTANCE_FIXED) {
                this.flags |= this.Flag.INSTANCE_FIXED;
            } else {
                this.flags &= ~this.Flag.INSTANCE_FIXED;
            }
        } else {
            if (this.flags & this.Flag.FIXED) {
                this.flags |= this.Flag.INSTANCE_FIXED;
            } else {
                this.flags &= ~this.Flag.INSTANCE_FIXED;
            }
        }
        if (this.children) {
            for (var key in this.children) {
                this.children[key].updateStatic();
            }
        }
    },
    Flag: {
        HIDDEN: 1 << 0,
        INSTANCE_HIDDEN: 1 << 1,
        ACTIVE: 1 << 2,
        INSTANCE_FIXED: 1 << 3,
        FIXED: 1 << 4,
        DEBUGGER: 1 << 5
    }
};

meta.createLayer = function createLayer(id) {
    var layer = meta.new(meta.Layer, id);
    meta.layer.attach(layer);
    return layer;
};

meta.destroyLayer = function destroyLayer(layer) {};

"use strict";

meta.Camera = function(x, y, width, height) {
    this.volume = new meta.AABB(x, y, width, height);
};

meta.Camera.prototype = {
    set: function(x, y, width, height) {
        this.volume.set(x, y, width, height);
    },
    remove: function() {},
    activate: function() {
        if (this.active) {
            return;
        }
        this.active = true;
        this.updateDraggable();
    },
    deactivate: function() {
        if (!this.active) {
            return;
        }
        this.active = false;
        this.updateDraggable();
    },
    update: function() {},
    updateZoom: function() {},
    onResize: function() {
        this.volume.resize(meta.engine.width, meta.engine.height);
    },
    set x(x) {
        if (this.volume.x === x) {
            return;
        }
        this.volume.position(x, this.volume.y);
        meta.emit("camera-move", this);
    },
    set y(value) {
        if (this.volume.y === y) {
            return;
        }
        this.volume.position(this.volume.x, y);
        meta.emit("camera-move", this);
    },
    get x() {
        return this.volume.x;
    },
    get y() {
        return this.volume.y;
    },
    set zoom(zoom) {
        if (this.$zoom === zoom) {
            return;
        }
        this.$zoom = zoom;
    },
    get zoom() {
        return this.$zoom;
    },
    set draggable(value) {
        if (this.$draggable === value) {
            return;
        }
        this.$draggable = value;
        this.updateDraggable();
    },
    get draggable() {
        return this.$draggable;
    },
    updateDraggable: function() {
        if (this.$draggable && this.active) {
            if (!this.$listeningEvents) {
                this.$listeningEvents = true;
                meta.on("input-move", this.drag, this);
                meta.on("input-down", this.handleInputDown, this);
                meta.on("input-up", this.handleInputUp, this);
            }
        } else {
            if (this.$listeningEvents) {
                this.$listeningEvents = false;
                meta.off("input-move", this.drag, this);
                meta.off("input-down", this.handleInputDown, this);
                meta.off("input-up", this.handleInputUp, this);
            }
        }
    },
    drag: function(event) {
        if (!this.$dragging) {
            return;
        }
        var diffX = (event.screenX - event.prevScreenX) * this.zoomRatio;
        var diffY = (event.screenY - event.prevScreenY) * this.zoomRatio;
        this.volume.move(-diffX, -diffY);
        meta.emit("camera-move", this);
    },
    handleInputDown: function(event) {
        if (event.keyCode === meta.key.BUTTON_LEFT) {
            this.$dragging = true;
        }
    },
    handleInputUp: function(event) {
        if (event.keyCode === meta.key.BUTTON_LEFT) {
            this.$dragging = false;
        }
    },
    volume: null,
    $zoom: 1,
    zoomPrev: 1,
    zoomRatio: 1,
    $zoomAuto: false,
    $active: false,
    $draggable: false,
    $dragging: false,
    $listeningEvents: false
};

meta.epsilon = 1e-6;

meta.nearestPowerOfTwo = function(value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
};

meta.upperPowerOfTwo = function(value) {
    value--;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value++;
    return value;
};

"use strict";

meta.Vector2 = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
};

meta.Vector2.prototype = {
    set: function(x, y) {
        this.x = x;
        this.y = y;
    },
    clone: function() {
        return new meta.Vector2(this.x, this.y);
    },
    copy: function(vec) {
        this.x = vec.x;
        this.y = vec.y;
    },
    add: function(vec) {
        this.x += vec.x;
        this.y += vec.y;
    },
    sub: function(vec) {
        this.x -= vec.x;
        this.y -= vec.y;
    },
    mul: function(vec) {
        this.x *= vec.x;
        this.y *= vec.y;
    },
    div: function(vec) {
        this.x /= vec.x;
        this.y /= vec.y;
    },
    scale: function(x, y) {
        this.x *= x;
        this.Y *= y;
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
    },
    min: function(x, y) {
        this.x = Math.min(this.x, x);
        this.y = Math.min(this.y, y);
    },
    max: function(x, y) {
        this.x = Math.max(this.x, x);
        this.y = Math.max(this.y, y);
    },
    length: function(vec) {
        var diffX = this.x - vec.x;
        var diffY = this.y - vec.y;
        return diffX * diffX + diffY * diffY;
    },
    squaredLength: function(vec) {
        return this.x * this.x + this.y * this.y;
    },
    inverse: function() {
        this.x = 1 / this.x;
        this.y = 1 / this.y;
    },
    magnitude: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    normalize: function() {
        var length = this.x * this.x + this.y * this.y;
        if (length > 0) {
            this.x = 0;
            this.y = 0;
        } else {
            length = Math.sqrt(length);
            this.x /= length;
            this.y /= length;
        }
    },
    dot: function(vec) {
        return this.x * vec.x + this.y * vec.y;
    },
    lerp: function(a, b, t) {
        this.x = a.x + t * (b.x - a.x);
        this.y = a.y + t * (b.y - a.y);
    },
    rand: function(min, max) {
        this.x = meta.random.number(min, max);
        this.y = meta.random.number(min, max);
    },
    exactEquals: function(vec) {
        if (this.x === vec.x && this.y === vec.y) {
            return true;
        }
        return false;
    },
    equals: function(vec) {
        return Math.abs(this.x - vec.x) <= meta.epsilon * Math.max(1, Math.abs(this.x), Math.abs(vec.x)) && Math.abs(this.y - vec.y) <= meta.epsilon * Math.max(1, Math.abs(this.y), Math.abs(vec.y));
    },
    getNormalized: function() {
        var mag = Math.sqrt(this.x * this.x + this.y * this.y);
        if (mag === 0) {
            return new meta.vector2(0, 0);
        }
        return new meta.vector2(this.x / mag, this.y / mag);
    },
    getAngle: function() {
        return Math.atan2(this.y, this.x) * 180 / Math.PI;
    },
    toString: function() {
        return "x:" + this.x + " y:" + this.y;
    }
};

"use strict";

meta.AABB = function(x, y, width, height) {
    this.set(x, y, width, height);
};

meta.AABB.prototype = {
    set: function(x, y, width, height) {
        this.x = x || 0;
        this.y = y || 0;
        this.width = width || 0;
        this.height = height || 0;
        this.minX = this.x;
        this.minY = this.y;
        this.maxX = this.x + this.width;
        this.maxY = this.y + this.height;
    },
    reset: function() {
        this.x = this.y = 0;
        this.width = this.height = 0;
        this.minX = this.minY = this.maxX = this.maxY = 0;
    },
    resize: function(width, height) {
        this.width = width;
        this.height = height;
        this.maxX = this.x + this.width;
        this.maxY = this.y + this.height;
    },
    move: function(diffX, diffY) {
        this.x += diffX;
        this.y += diffY;
        this.minX = this.x;
        this.minY = this.y;
        this.maxX = this.x + this.width;
        this.maxY = this.y + this.height;
    },
    position: function(x, y) {
        this.x = x;
        this.y = y;
        this.minX = this.x;
        this.minY = this.y;
        this.maxX = this.x + this.width;
        this.maxY = this.y + this.height;
    }
};

"use strict";

meta.Matrix4 = function(src) {
    if (src) {
        if (src instanceof Float32Array) {
            this.m = new Float32Array(src);
        } else if (src instanceof meta.Matrix4) {
            this.m = new Float32Array(src.m);
        }
    } else {
        this.create();
    }
};

meta.Matrix4.prototype = {
    create: function() {
        this.m = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);
    },
    clone: function() {
        return new meta.Matrix4(this.m);
    },
    copy: function(matrix) {
        this.m.set(matrix.m);
    },
    set: function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        this.m[0] = m00;
        this.m[1] = m01;
        this.m[2] = m02;
        this.m[3] = m03;
        this.m[4] = m10;
        this.m[5] = m11;
        this.m[6] = m12;
        this.m[7] = m13;
        this.m[8] = m20;
        this.m[9] = m21;
        this.m[10] = m22;
        this.m[11] = m23;
        this.m[12] = m30;
        this.m[13] = m31;
        this.m[14] = m32;
        this.m[15] = m33;
    },
    identity: function() {
        this.m[0] = 1;
        this.m[1] = 0;
        this.m[2] = 0;
        this.m[3] = 0;
        this.m[4] = 0;
        this.m[5] = 1;
        this.m[6] = 0;
        this.m[7] = 0;
        this.m[8] = 0;
        this.m[9] = 0;
        this.m[10] = 1;
        this.m[11] = 0;
        this.m[12] = 0;
        this.m[13] = 0;
        this.m[14] = 0;
        this.m[15] = 1;
    },
    transpose: function() {
        var a01 = this.m[1];
        var a02 = this.m[2];
        var a03 = this.m[3];
        var a12 = this.m[6];
        var a13 = this.m[7];
        var a23 = this.m[11];
        this.m[1] = this.m[4];
        this.m[2] = this.m[8];
        this.m[3] = this.m[12];
        this.m[4] = a01;
        this.m[6] = this.m[9];
        this.m[7] = this.m[13];
        this.m[8] = a02;
        this.m[9] = a12;
        this.m[11] = this.m[14];
        this.m[12] = a03;
        this.m[13] = a13;
        this.m[14] = a23;
    },
    translate: function(x, y, z) {
        this.m[12] += this.m[0] * x + this.m[4] * y + this.m[8] * z;
        this.m[13] += this.m[1] * x + this.m[5] * y + this.m[9] * z;
        this.m[14] += this.m[2] * x + this.m[6] * y + this.m[10] * z;
        this.m[15] += this.m[3] * x + this.m[7] * y + this.m[11] * z;
    },
    scale: function(x, y, z) {
        this.m[0] *= x;
        this.m[1] *= x;
        this.m[2] *= x;
        this.m[3] *= x;
        this.m[4] *= y;
        this.m[5] *= y;
        this.m[6] *= y;
        this.m[7] *= y;
        this.m[8] *= z;
        this.m[9] *= z;
        this.m[10] *= z;
        this.m[11] *= z;
    },
    ortho: function(left, right, bottom, top, near, far) {
        var leftRight = 1 / (left - right);
        var bottomTop = 1 / (bottom - top);
        var nearFar = 1 / (near - far);
        this.m[0] = -2 * leftRight;
        this.m[1] = 0;
        this.m[2] = 0;
        this.m[3] = 0;
        this.m[4] = 0;
        this.m[5] = -2 * bottomTop;
        this.m[6] = 0;
        this.m[7] = 0;
        this.m[8] = 0;
        this.m[9] = 0;
        this.m[10] = 2 * nearFar;
        this.m[11] = 0;
        this.m[12] = (left + right) * leftRight;
        this.m[13] = (top + bottom) * bottomTop;
        this.m[14] = (far + near) * nearFar;
        this.m[15] = 1;
    },
    perspective: function(fovy, aspect, near, far) {
        var fov = 1 / Math.tan(fovy / 2);
        var nearFar = 1 / (near - far);
        this.m[0] = fov / aspect;
        this.m[1] = 0;
        this.m[2] = 0;
        this.m[3] = 0;
        this.m[4] = 0;
        this.m[5] = fov;
        this.m[6] = 0;
        this.m[7] = 0;
        this.m[8] = 0;
        this.m[9] = 0;
        this.m[10] = (far + near) * nearFar;
        this.m[11] = -1;
        this.m[12] = 0;
        this.m[13] = 0;
        this.m[14] = 2 * far * near * nearFar;
        this.m[15] = 0;
    },
    frustum: function(left, right, bottom, top, near, far) {
        var rightLeft = 1 / (right - left);
        var topBottom = 1 / (top - bottom);
        var nearFar = 1 / (near - far);
        this.m[0] = near * 2 * rightLeft;
        this.m[1] = 0;
        this.m[2] = 0;
        this.m[3] = 0;
        this.m[4] = 0;
        this.m[5] = near * 2 * topBottom;
        this.m[6] = 0;
        this.m[7] = 0;
        this.m[8] = (right + left) * rightLeft;
        this.m[9] = (top + bottom) * topBottom;
        this.m[10] = (far + near) * nearFar;
        this.m[11] = -1;
        this.m[12] = 0;
        this.m[13] = 0;
        this.m[14] = far * near * 2 * nearFar;
        this.m[15] = 0;
    },
    fromTransformation: function(x, y, z) {
        this.m[0] = 1;
        this.m[1] = 0;
        this.m[2] = 0;
        this.m[3] = 0;
        this.m[4] = 0;
        this.m[5] = 1;
        this.m[6] = 0;
        this.m[7] = 0;
        this.m[8] = 0;
        this.m[9] = 0;
        this.m[10] = 1;
        this.m[11] = 0;
        this.m[12] = x;
        this.m[13] = y;
        this.m[14] = z;
        this.m[15] = 1;
    },
    toString: function() {
        return "[" + this.m[0] + ", " + this.m[1] + ", " + this.m[2] + ", " + this.m[3] + this.m[4] + ", " + this.m[5] + ", " + this.m[6] + ", " + this.m[7] + this.m[8] + ", " + this.m[9] + ", " + this.m[10] + ", " + this.m[11] + this.m[12] + ", " + this.m[13] + ", " + this.m[14] + ", " + this.m[15] + "]";
    }
};

"use strict";

meta.Random = function() {
    this.seed = 0;
    this.a = 0;
    this.m = 0;
    this.q = 0;
    this.r = 0;
    this.oneOverM = 0;
    this.init();
};

meta.Random.prototype = {
    init: function() {
        this.setSeed(Date.now(), true);
    },
    generate: function() {
        var hi = Math.floor(this.seed / this.q);
        var lo = this.seed % this.q;
        var test = this.a * lo - this.r * hi;
        if (test > 0) {
            this.seed = test;
        } else {
            this.seed = test + this.m;
        }
        return this.seed * this.oneOverM;
    },
    number: function(min, max) {
        var number = this.generate();
        return Math.round((max - min) * number + min);
    },
    numberF: function(min, max) {
        var number = this.generate();
        return (max - min) * number + min;
    },
    setSeed: function(seed, useTime) {
        if (useTime !== void 0) {
            useTime = true;
        }
        if (useTime === true) {
            var date = new Date();
            this.seed = seed + date.getSeconds() * 16777215 + date.getMinutes() * 65535;
        } else {
            this.seed = seed;
        }
        this.a = 48271;
        this.m = 2147483647;
        this.q = Math.floor(this.m / this.a);
        this.r = this.m % this.a;
        this.oneOverM = 1 / this.m;
    }
};

meta.random = new meta.Random();

"use strict";

meta.Color = function(r, g, b) {
    this.r = r || 0;
    this.g = g || 0;
    this.b = b || 0;
};

meta.Color.prototype = {
    setHex: function(hex) {
        var hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
    },
    getHex: function() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    }
};

"use strict";

meta.renderer = {
    setup: function() {
        var gl = meta.engine.gl;
        this.gl = gl;
        this.bgColor = 14540253;
        this.prepareVBO();
        gl.activeTexture(gl.TEXTURE0);
        gl.enable(gl.BLEND);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        this.entities.length = 16;
        this.entitiesRemove.length = 8;
        meta.on("update", this.update, this);
    },
    prepareVBO: function() {
        var gl = meta.engine.gl;
        var indices = [ 0, 1, 2, 0, 2, 3 ];
        var uvCoords = [ 0, 0, 1, 0, 1, 1, 0, 1 ];
        this.vertices = new Float32Array(8);
        this.vbo = gl.createBuffer();
        this.uv = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uv);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvCoords), gl.STATIC_DRAW);
        this.indiceBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indiceBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    },
    update: function(tDelta) {
        if (this.numEntitiesRemove > 0) {
            for (var n = 0; n < this.numEntitiesRemove; n++) {
                var entity = this.entitiesRemove[n];
                var index = this.entities.indexOf(entity);
                if (index === -1) {
                    console.warn("(meta.renderer.update) Trying to remove entity that is not part of visible entities");
                    continue;
                }
                this.numEntities--;
                this.entities[index] = this.entities[this.numEntities];
            }
            this.numEntitiesRemove = 0;
        }
        if (this.needSort) {
            this.entities.sort(this.sortFunc);
            this.needSort = false;
            this.needRender = true;
        }
    },
    render: function() {
        var gl = this.gl;
        var fixed = false;
        gl.clear(gl.COLOR_BUFFER_BIT);
        var projMatrix = new meta.Matrix4();
        projMatrix.ortho(0, meta.engine.width, meta.engine.height, 0, 0, 1);
        projMatrix.translate(-meta.camera.x, -meta.camera.y, 0);
        var staticProjMatrix = new meta.Matrix4();
        staticProjMatrix.ortho(0, meta.engine.width, meta.engine.height, 0, 0, 1);
        for (var n = 0; n < this.numEntities; n++) {
            var entity = this.entities[n];
            var shader = entity.$shader;
            if (!shader) {
                continue;
            }
            if (shader !== this.currShader) {
                this.currShader = shader;
                this.currShader.use();
                gl.uniform1i(this.currShader.uniform.texture, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
                gl.vertexAttribPointer(this.currShader.attrib.vertexPos, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.uv);
                gl.vertexAttribPointer(this.currShader.attrib.uvCoords, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indiceBuffer);
            }
            var layer = entity.$layer;
            if (layer.flags & layer.Flag.INSTANCE_FIXED) {
                gl.uniformMatrix4fv(this.currShader.uniform.projMatrix, false, staticProjMatrix.m);
            } else {
                gl.uniformMatrix4fv(this.currShader.uniform.projMatrix, false, projMatrix.m);
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
            entity.render(gl, this.vertices);
        }
        this.needRender = false;
        this.currShader = null;
    },
    sortFunc: function(a, b) {
        return a.totalZ - b.totalZ;
    },
    onResize: function() {
        this.gl.viewport(0, 0, meta.engine.width, meta.engine.height);
    },
    addEntities: function(entities) {
        for (var n = 0; n < entities.length; n++) {
            this.addEntity(entities[n]);
        }
    },
    removeEntities: function(entities) {
        for (var n = 0; n < entities.length; n++) {
            this.removeEntity(entities[n]);
        }
    },
    addEntity: function(entity) {
        if (entity.flags & entity.Flag.RENDERING) {
            return;
        }
        entity.flags |= entity.Flag.RENDERING;
        if (this.numEntities === this.entities.length) {
            this.entities.length += 8;
        }
        this.entities[this.numEntities++] = entity;
        this.needSort = true;
    },
    removeEntity: function(entity) {
        if ((entity.flags & entity.Flag.RENDERING) === 0) {
            return;
        }
        entity.flags &= ~entity.Flag.RENDERING;
        if (this.numEntitiesRemove === this.entitiesRemove.length) {
            this.entitiesRemove.length += 8;
        }
        this.entitiesRemove[this.numEntitiesRemove++] = entity;
    },
    set bgColor(hex) {
        if (this.$bgColor.getHex() === hex) {
            return;
        }
        this.$bgColor.setHex(hex);
        this.gl.clearColor(this.$bgColor.r, this.$bgColor.g, this.$bgColor.b, 1);
    },
    get color() {
        this.$bgColor;
    },
    entities: [],
    numEntities: 0,
    entitiesRemove: [],
    numEntitiesRemove: 0,
    vbo: null,
    uv: null,
    indiceBuffer: null,
    $bgColor: new meta.Color(0, 0, 0),
    currShader: null
};

"use strict";

meta.renderer.SpriteBatch = function() {};

meta.renderer.SpriteBatch.prototype = {
    create: function() {},
    capacity: 100
};

"use strict";

meta.resources = {
    add: function(resource) {
        if (!resource) {
            return console.warn("(meta.resources.add) Invalid resource passed");
        }
        if (!resource.type) {
            return console.warn("(meta.resources.add) Invalid resource type");
        }
        if (resource.flags & resource.Flag.ADDED) {
            return console.warn("(meta.resources.add) Resource is already added to manager: " + resource.id);
        }
        var buffer = this.table[resource.type];
        if (!buffer) {
            buffer = {};
            this.table[type] = buffer;
        }
        if (buffer[resource.id]) {
            return console.warn("(meta.resources.load) There is already resource with id: " + resource.id + ", and type: " + resource.type);
        }
        resource.flags |= resource.Flag.ADDED;
        buffer[resource.id] = resource;
    },
    remove: function(resource) {
        if (!resource) {
            return console.warn("(meta.resources.remove) Invalid resource passed");
        }
        if ((resource.flags & resource.Flag.ADDED) === 0) {
            return console.warn("(meta.resources.remove) Resource has not been added to the manager: " + resource.id);
        }
        var buffer = this.table[resource.type];
        if (!buffer) {
            return console.warn("(meta.resources.remove) No resources with such type added: " + resource.type);
        }
        if (resource instanceof meta.Resource) {
            if (!buffer[resource.id]) {
                return console.warn("(meta.resources.remove) No resources with such type added: " + resource.type);
            }
            delete buffer[resource.id];
        } else if (typeof resource === "string") {
            var ref = buffer[resource];
            if (!ref) {
                return console.warn("(meta.resources.remove) No resources with such type added: " + resource.type);
            }
            delete buffer[resource];
            resource = ref;
        } else {
            return console.warn("(meta.resources.remove) Invalid resource or id passed");
        }
        resource.$remove();
    },
    move: function(resource, newId) {
        if (!resource) {
            return console.warn("(meta.resources.move) Invalid resource passed");
        }
        if ((resource.flags & resource.Flag.ADDED) === 0) {
            return console.warn("(meta.resources.move) Resource has not been added to manager");
        }
        var buffer = this.table[resource.type];
        if (!buffer || !buffer[resource.$id]) {
            return console.warn("(meta.resources.move) No such resource found: " + resource.$id);
        }
        delete buffer[resource.$id];
        resource.$id = newId;
        buffer[newId] = resource;
    },
    load: function(type, cls, params) {
        var buffer = this.table[type];
        if (!buffer) {
            buffer = {};
            this.table[type] = buffer;
        }
        var resource = meta.new(cls, params);
        if (!resource.id) {
            meta.delete(resource);
            console.warn("(meta.resources.load) Created resource with invalid ID from params: `" + params + "`");
            return null;
        }
        buffer[resource.id] = resource;
        return resource;
    },
    get: function(type, id) {
        var buffer = this.table[type];
        if (!buffer) {
            console.warn("(meta.resources.get) No resources found for type: " + type);
            return;
        }
        var resource = buffer[id];
        if (!resource) {
            console.warn("(meta.resources.get) There is no resource with id: " + id + ", and type: " + type);
            return;
        }
        return resource;
    },
    loadShader: function(id, params) {
        return this.load("shader", meta.Shader, id, params);
    },
    getShader: function(id) {
        return this.get("shader", id);
    },
    loadTexture: function(id, params) {
        return this.load("texture", meta.Texture, id, params);
    },
    getTexture: function(id) {
        return this.get("texture", id);
    },
    loadVideo: function(id, params) {
        return this.load("video", meta.Video, id, params);
    },
    getVideo: function(id) {
        return this.get("video", id);
    },
    rootPath: "",
    table: {
        texture: {},
        shader: {},
        audio: {},
        atlas: {},
        video: {}
    }
};

"use strict";

meta.class("meta.Resource", {
    init: function(params, id) {
        this.create(params, id);
    },
    create: function(params, id) {
        if (this.flags & this.Flag.ADDED) {
            return;
        }
        if (!id) {
            if (typeof params === "string") {
                this.id = meta.getNameFromPath(params);
            } else if (params instanceof Object && params.id) {
                this.id = params.id;
            } else {
                this.id = meta.genUniqueId();
            }
        } else {
            this.id = id;
        }
        if (this.setup) {
            this.setup(params);
        }
        if (params) {
            this.loadParams(params);
        }
        meta.resources.add(this);
    },
    remove: function() {
        if (this.flags & this.Flag.ADDED) {
            meta.resources.remove(this.type, this.id);
        } else {
            this.$remove();
        }
    },
    $remove: function() {
        this.emit("removed");
        if (this.cleanup) {
            this.cleanup();
        }
        this.$id = null;
        if (this.watchers) {
            this.watchers.length = 0;
        }
    },
    loadParams: function(params) {
        if (typeof params === "object") {
            for (var key in params) {
                this[key] = params[key];
            }
        }
    },
    watch: function(func, owner) {
        var watcher = new meta.Watcher(func, owner);
        if (this.watchers) {
            this.watchers.push(watcher);
        } else {
            this.watchers = [ watcher ];
        }
    },
    unwatch: function(owner) {
        var num = this.watchers.length;
        for (var n = 0; n < num; n++) {
            if (this.watchers[n].owner === owner) {
                this.watchers[n] = this.watchers[num - 1];
                this.watchers.pop();
                break;
            }
        }
    },
    emit: function(event) {
        if (!this.watchers) {
            return;
        }
        for (var n = 0; n < this.watchers.length; n++) {
            var watcher = this.watchers[n];
            watcher.func.call(watcher.owner, event);
        }
    },
    set id(id) {
        if (id === this.$id) {
            return;
        }
        if (this.$id) {
            meta.resources.move(this, id);
        } else {
            this.$id = id;
        }
    },
    get id() {
        return this.$id;
    },
    get loaded() {
        return (this.flags & this.Flag.LOADED) === this.Flag.LOADED;
    },
    set loading(value) {
        if (value) {
            if (this.flags & this.Flag.LOADING) {
                return;
            }
            this.flags |= this.Flag.LOADING;
        } else {
            this.flags &= ~this.Flag.LOADING;
            this.flags |= this.Flag.LOADED;
            this.emit("loaded");
        }
    },
    get loading() {
        return (this.flags & this.Flag.LOADING) === this.Flag.LOADING;
    },
    set data(data) {
        if (this.$data === data) {
            return;
        }
        if (this.$data) {
            this.$data.unwatch(this.handleData, this);
        }
        this.$data = data;
        if (this.$data) {
            var table = meta.resources.table[this.type];
            delete table[this.id];
            var raw = data.raw;
            for (var key in raw) {
                var value = this[key];
                var newValue = raw[key];
                if (value === undefined || value === newValue) {
                    continue;
                }
                this[key] = raw[key];
            }
            this.id = this.$data.id;
            table[this.id] = this;
            this.$data.watch(this.handleData, this);
        }
    },
    get data() {
        return this.$data;
    },
    handleData: function(event) {
        console.log("data_changed");
    },
    Flag: {
        ADDED: 1 << 0,
        LOADED: 1 << 1,
        LOADING: 1 << 2
    },
    $id: null,
    type: null,
    $data: null,
    watchers: null,
    flags: 0
});

"use strict";

meta.class("meta.Texture", "meta.Resource", {
    setup: function() {
        this.instance = meta.engine.gl.createTexture();
    },
    loadParams: function(params) {
        if (params instanceof HTMLCanvasElement) {
            this.createFromImage(params);
        } else {
            if (typeof params === "string") {
                this.path = params;
            } else if (params instanceof Object) {
                for (var key in params) {
                    this[key] = params[key];
                }
            }
        }
    },
    cleanup: function() {
        meta.engine.gl.deleteTexture(this.instance);
        this.instance = null;
        this.image = null;
        this.width = 0;
        this.height = 0;
    },
    load: function(path) {
        if (this.loading) {
            return;
        }
        this.loading = true;
        if (!this.image) {
            var self = this;
            this.image = new Image();
            this.image.onload = function() {
                self.createFromImage(self.image);
            };
        }
        if (!path) {
            this.ext = null;
            this.$path = null;
            this.image.src = "";
            this.createFromImage(this.image);
        } else {
            this.ext = meta.getExtFromPath(path);
            this.$path = path;
            this.image.src = meta.resources.rootPath + path;
        }
    },
    createFromImage: function(img) {
        this.image = img;
        this.width = this.image.width;
        this.height = this.image.height;
        var gl = meta.engine.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.instance);
        if (this.isPowTwo()) {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
        } else {
            if (meta.flags.autoPowTwo) {
                this.resizePowTwo();
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.generateMipmap(gl.TEXTURE_2D);
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            }
        }
        this.image.src = "";
        if (this.$anisotropy) {
            var ext = meta.getExt("EXT_texture_filter_anisotropic");
            if (ext) {
                gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, meta.getExtParam(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            }
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
        this.loading = false;
    },
    resizePowTwo: function() {
        var canvas = document.createElement("canvas");
        canvas.imageSmoothingEnabled = false;
        canvas.width = meta.upperPowerOfTwo(this.width);
        canvas.height = meta.upperPowerOfTwo(this.height);
        var context = canvas.getContext("2d");
        context.drawImage(this.image, 0, 0, canvas.width, canvas.height);
        console.warn("(meta.Texture.resizePowTwo) Resized image `" + this.id + "` from (" + this.width + "x" + this.height + ") to (" + canvas.width + "x" + canvas.height + ")");
        this.fullWidth = canvas.width;
        this.fullHeight = canvas.height;
        this.image = canvas;
    },
    isPowTwo: function() {
        var isWidth = this.width != 0 && (this.width & ~this.width + 1) === this.width;
        if (!isWidth) {
            return false;
        }
        var isHeight = this.height != 0 && (this.height & ~this.height + 1) === this.height;
        if (!isHeight) {
            return false;
        }
        return true;
    },
    set path(path) {
        if (this.$path === path) {
            return;
        }
        this.$path = path;
        if (path) {
            this.load(path);
        }
    },
    get path() {
        return this.$path;
    },
    set anisotropy(value) {
        if (this.$anisotropy === value) {
            return;
        }
        this.$anisotropy = value;
        if (this.instance) {
            var ext = meta.getExt("EXT_texture_filter_anisotropic");
            if (!ext) {
                return;
            }
            var gl = meta.engine.gl;
            gl.bindTexture(gl.TEXTURE_2D, this.instance);
            if (value) {
                gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, meta.getExtParam(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            } else {
                gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, 1);
            }
        }
    },
    get anisotropy() {
        return this.$anisotropy;
    },
    type: "texture",
    instance: null,
    image: null,
    width: 0,
    height: 0,
    fullWidth: 0,
    fullHeight: 0,
    ext: null,
    $path: null,
    $anisotropy: true
});

"use strict";

meta.class("meta.Video", "meta.Resource", {
    onCanPlay: function() {},
    onEnd: function() {},
    set path(path) {
        if (this.$path === path) {
            return;
        }
        this.$path = path;
        if (!this.videoElement) {
            var self = this;
            this.videoElement = document.createElement("video");
            this.videoElement.preload = "auto";
            this.videoElement.oncanplaythrough = function() {
                self.onCanPlay();
            };
            this.videoElement.onended = function() {
                self.onEnd();
            };
        }
        this.videoElement.src = path;
    },
    get path() {
        return this.$path;
    },
    type: "video",
    $path: null,
    videoElement: null
});

"use strict";

meta.class("meta.Shader", "meta.Resource", {
    cleanup: function() {
        var gl = meta.engine.gl;
        gl.deleteProgram(this.program);
        gl.deleteShader(this.$vertexShader);
        gl.deleteShader(this.$fragmentShader);
        this.program = null;
        this.$vertexShader = null;
        this.$fragmentShader = null;
    },
    compile: function() {
        if (!this.$vertexShader) {
            return;
        }
        if (!this.$fragmentShader) {
            return;
        }
        var gl = meta.engine.gl;
        this.program = gl.createProgram();
        gl.attachShader(this.program, this.$vertexShader);
        gl.attachShader(this.program, this.$fragmentShader);
        gl.linkProgram(this.program);
        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
            console.warn("(meta.Shader.compile) Shader program failed to link: " + gl.getShaderInfoLog(this.program));
            gl.deleteProgram(this.program);
            gl.deleteShader(this.$vertexShader);
            gl.deleteShader(this.$fragmentShader);
            this.program = null;
            this.$vertexShader = null;
            this.$fragmentShader = null;
            return;
        }
        this.loadAttribs();
        this.loadUniforms();
    },
    use: function() {
        meta.engine.gl.useProgram(this.program);
    },
    loadAttribs: function() {
        this.attrib = {};
        var gl = meta.engine.gl;
        var num = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);
        for (var n = 0; n < num; n++) {
            var attrib = gl.getActiveAttrib(this.program, n);
            var attribLoc = gl.getAttribLocation(this.program, attrib.name);
            gl.enableVertexAttribArray(attribLoc);
            this.attrib[attrib.name] = attribLoc;
        }
    },
    loadUniforms: function() {
        this.uniform = {};
        var gl = meta.engine.gl;
        var num = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
        for (var n = 0; n < num; n++) {
            var uniform = gl.getActiveUniform(this.program, n);
            var name = uniform.name.replace("[0]", "");
            this.uniform[name] = gl.getUniformLocation(this.program, name);
        }
    },
    set vertexShader(src) {
        var gl = meta.engine.gl;
        if (!this.$vertexShader) {
            this.$vertexShader = gl.createShader(gl.VERTEX_SHADER);
        }
        if (src instanceof Array) {
            src = src.join("\n");
        }
        gl.shaderSource(this.$vertexShader, src);
        gl.compileShader(this.$vertexShader);
        if (!gl.getShaderParameter(this.$vertexShader, gl.COMPILE_STATUS)) {
            console.warn("(meta.Shader.vertexShader) [" + this.id + "]: " + gl.getShaderInfoLog(this.$vertexShader));
            gl.deleteShader(this.$vertexShader);
            this.$vertexShader = null;
            return;
        }
        if (this.$fragmentShader) {
            this.compile();
        }
    },
    get vertexShader() {
        return this.$vertexShader;
    },
    set fragmentShader(src) {
        var gl = meta.engine.gl;
        if (!this.$fragmentShader) {
            this.$fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        }
        if (src instanceof Array) {
            src = src.join("\n");
        }
        gl.shaderSource(this.$fragmentShader, src);
        gl.compileShader(this.$fragmentShader);
        if (!gl.getShaderParameter(this.$fragmentShader, gl.COMPILE_STATUS)) {
            console.warn("(meta.Shader.fragmentShader) [" + this.id + "]: " + gl.getShaderInfoLog(this.$fragmentShader));
            gl.deleteShader(this.$fragmentShader);
            this.$fragmentShader = null;
            return;
        }
        if (this.$vertexShader) {
            this.compile();
        }
    },
    get fragmentShader() {
        return this.$fragmentShader;
    },
    type: "shader",
    attributre: null,
    uniform: null,
    $vertexShader: null,
    $fragmentShader: null
});

meta.on("preload", function() {
    meta.new(meta.Shader, {
        id: "sprite",
        vertexShader: [ "attribute vec3 vertexPos;", "attribute vec2 uvCoords;", "uniform mat4 projMatrix;", "uniform float angle;", "varying highp vec2 var_uvCoords;", "void main(void) {", "	float angleX = sin(angle);", "	float angleY = cos(angle);", "	vec2 rotatedPos = vec2(vertexPos.x * angleY + vertexPos.y * angleX, vertexPos.y * angleY - vertexPos.x * angleX);", "	gl_Position = projMatrix * vec4(rotatedPos, vertexPos.z, 1.0);", "	var_uvCoords = vec2(uvCoords.s, uvCoords.t);", "}" ],
        fragmentShader: [ "varying highp vec2 var_uvCoords;", "uniform sampler2D texture;", "void main(void) {", "	gl_FragColor = texture2D(texture, vec2(var_uvCoords.s, var_uvCoords.t));", "}" ]
    });
    meta.new(meta.Shader, {
        id: "tiling",
        vertexShader: [ "#define PI 3.1415926535897932384626433832795", "attribute vec3 vertexPos;", "attribute vec2 uvCoords;", "uniform mat4 projMatrix;", "uniform float tilesX;", "uniform float tilesY;", "uniform float offsetX;", "uniform float offsetY;", "varying highp vec2 var_uvCoords;", "void main(void) {", "	gl_Position = projMatrix * vec4(vertexPos, 1.0);", "	var_uvCoords = vec2(uvCoords.s * tilesX + offsetX, uvCoords.t * tilesY + offsetY);", "}" ],
        fragmentShader: [ "varying highp vec2 var_uvCoords;", "uniform sampler2D texture;", "void main(void) {", "	gl_FragColor = texture2D(texture, vec2(var_uvCoords.s, var_uvCoords.t));", "}" ]
    });
});

"use strict";

meta.class("meta.Sprite", {
    init: function(params) {
        this.volume = new meta.AABB(0, 0, 0, 0);
        this.create(params);
    },
    create: function(params) {
        this.flags = 0;
        this.loadParams(params);
        if (!this.$shader) {
            this.$shader = meta.resources.get("shader", "sprite");
        }
    },
    cleanup: function() {
        if (this.flags & this.Flag.REMOVED) {
            return;
        }
        this.flags |= this.Flag.REMOVED;
        this.volume.reset();
    },
    remove: function() {
        if (this.$layer) {
            this.$layer.remove(this);
        } else {
            this.cleanup();
        }
    },
    loadParams: function(params) {
        if (!params) {
            return;
        }
        if (typeof params === "string") {
            this.texture = params;
        } else if (params instanceof meta.Texture) {
            this.texture = params;
        } else {
            for (var key in params) {
                this[key] = params[key];
            }
        }
    },
    render: function(gl, buffer) {
        if (!this.texture) {
            return;
        }
        if (!this.texture.loaded) {
            return;
        }
        buffer[0] = this.volume.minX;
        buffer[1] = this.volume.minY;
        buffer[2] = this.volume.maxX;
        buffer[3] = this.volume.minY;
        buffer[4] = this.volume.maxX;
        buffer[5] = this.volume.maxY;
        buffer[6] = this.volume.minX;
        buffer[7] = this.volume.maxY;
        gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.DYNAMIC_DRAW);
        gl.bindTexture(gl.TEXTURE_2D, this.texture.instance);
        gl.uniform1f(this.$shader.uniform.angle, this.$angle);
        var numTilesX = this.volume.width / this.texture.width;
        gl.uniform1f(this.$shader.uniform.tilesX, numTilesX);
        var numTilesY = this.volume.height / this.texture.height;
        gl.uniform1f(this.$shader.uniform.tilesY, numTilesY);
        var offsetX = meta.camera.x % 256;
        if (offsetX !== 0) {
            offsetX = 1 / 256 * offsetX;
        }
        var offsetY = meta.camera.y % 256;
        if (offsetY !== 0) {
            offsetY = 1 / 256 * offsetY;
        }
        gl.uniform1f(this.$shader.uniform.offsetX, offsetX);
        gl.uniform1f(this.$shader.uniform.offsetY, offsetY);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    },
    position: function(x, y) {
        this.volume.position(x, y);
        this.updatePosition();
    },
    move: function(deltaX, deltaY) {
        this.volume.move(deltaX, deltaY);
        this.updatePosition();
    },
    updatePosition: function() {},
    updateZ: function() {
        this.totalZ = this.$z;
        meta.renderer.needSort = true;
    },
    set x(x) {
        this.volume.position(x, this.volume.y);
        this.updatePosition();
    },
    set y(y) {
        this.volume.position(this.volume.x, y);
        this.updatePosition();
    },
    get x() {
        return this.volume.x;
    },
    get y() {
        return this.volume.y;
    },
    set z(value) {
        this.$z = value;
        this.updateZ();
    },
    get z() {
        return this.$z;
    },
    set angle(degree) {
        var newAngle = degree * Math.PI / 180;
        if (this.$angle === newAngle) {
            return;
        }
        this.$angle = newAngle;
    },
    set angleRad(angle) {
        if (this.$angle === angle) {
            return;
        }
        this.$angle = angle;
    },
    get angle() {
        return this.$angle * 180 / Math.PI;
    },
    get angleRad() {
        return this.$angle;
    },
    resize: function(width, height) {
        this.volume.resize(width, height);
        this.updateAnchor();
    },
    set width(width) {
        if (this.volume.width === width) {
            return;
        }
        this.volume.resize(width, this.volume.height);
        this.updateAnchor();
    },
    set height(height) {
        if (this.volume.height === height) {
            return;
        }
        this.volume.resize(this.volume.width, height);
        this.updateAnchor();
    },
    get width() {
        return this.volume.width;
    },
    get height() {
        return this.volume.height;
    },
    anchor: function(x, y) {
        this.$anchorX = x;
        this.$anchorY = y;
        this.updateAnchor();
    },
    set anchorX(x) {
        if (this.$anchorX === x) {
            return;
        }
        this.$anchorX = x;
        this.updateAnchor();
    },
    set anchorY(y) {
        if (this.$anchorY === y) {
            return;
        }
        this.$anchorY = y;
        this.updateAnchor();
    },
    get anchorX() {
        return this.$anchorX;
    },
    get anchorY() {
        return this.$anchorY;
    },
    updateAnchor: function() {},
    pivot: function(x, y) {
        if (this.$pivotX === x && this.$pivotY === y) {
            return;
        }
        this.$pivotX = x;
        this.$pivotY = y;
    },
    set pivotX(x) {
        if (this.$pivotX === x) {
            return;
        }
        this.$pivotX = x;
    },
    set pivotY(y) {
        if (this.$pivotY === y) {
            return;
        }
        this.$pivotY = y;
    },
    get pivotX() {
        return this.$pivotX;
    },
    get pivotY() {
        return this.$pivotY;
    },
    scale: function(x, y) {
        if (this.$scaleX === x && this.$scaleY === y) {
            return;
        }
        this.$scaleX = x;
        this.$scaleY = y;
    },
    set scaleX(x) {
        if (this.$scaleX === x) {
            return;
        }
        this.$scaleX = x;
    },
    set scaleY(y) {
        if (this.$scaleY === y) {
            return;
        }
        this.$scaleY = y;
    },
    get scaleX() {
        return this.$scaleX;
    },
    get scaleY() {
        return this.$scaleY;
    },
    onClick: null,
    onPress: null,
    set layer(layer) {
        if (this.$layer) {
            this.$layer.remove(this);
        }
        this.$setLayer(layer);
    },
    get layer() {
        return this.$layer;
    },
    $setLayer: function(layer) {
        this.$layer = layer;
        if (this.children) {
            for (var n = 0; n < this.children.n++; n++) {
                this.children[n].$setLayer(layer);
            }
        }
    },
    set texture(texture) {
        if (typeof texture === "string") {
            if (texture === "") {
                texture = null;
            } else {
                texture = meta.resources.getTexture(texture);
            }
        }
        if (this.$texture) {
            if (texture && this.$texture.id === texture.id) {
                return;
            }
            this.$texture.unwatch(this);
        }
        this.$texture = texture;
        if (this.$texture) {
            if (this.$texture.loaded) {
                this.updateFromTexture();
            }
            this.$texture.watch(this.handleTexture, this);
        }
    },
    get texture() {
        return this.$texture;
    },
    handleTexture: function(event) {
        if (event === "loaded" || event === "updated") {
            this.updateFromTexture();
        }
    },
    updateFromTexture: function() {
        this.volume.resize(this.$texture.width, this.$texture.height);
    },
    set shader(shader) {
        if (typeof shader === "string") {
            shader = meta.resources.getShader(shader);
        }
        if (this.$shader) {
            if (this.$shader.id === shader.id) {
                return;
            }
            this.$shader.unwatch(this);
        }
        this.$shader = shader;
        if (this.$shader) {
            this.$shader.watch(this.handleShader, this);
        }
    },
    get shader() {
        return this.$shader;
    },
    handleShader: function(event, data) {},
    set data(data) {
        if (this.$data === data) {
            return;
        }
        if (this.$data) {
            this.$data.unwatch(this.handleData, this);
        }
        this.$data = data;
        if (this.$data) {
            var raw = data.raw;
            for (var key in raw) {
                var value = this[key];
                var newValue = raw[key];
                if (value === undefined || value === newValue) {
                    continue;
                }
                this[key] = raw[key];
            }
            this.$data.watch(this.handleData, this);
        }
    },
    get data() {
        return this.$data;
    },
    handleData: function(action, key, value, index, data) {
        switch (action) {
          case "set":
            {
                if (this[key] === undefined) {
                    return;
                }
                this[key] = value;
            }
            break;
        }
    },
    Flag: {
        REMOVE: 1 << 0,
        REMOVED: 1 << 1,
        INSTANCE_ENABLED: 1 << 2,
        INSTANCE_VISIBLE: 1 << 3,
        ROOT: 1 << 4,
        RENDERING: 1 << 5
    },
    $layer: null,
    parent: null,
    children: null,
    volume: null,
    flags: 0,
    $z: 0,
    totalZ: 0,
    $angle: null,
    $texture: null,
    $shader: null,
    $scaleX: 1,
    $scaleY: 1,
    $anchorX: 0,
    $anchorY: 0,
    $pivotX: 0,
    $pivotY: 0,
    $data: null
});

"use strict";

meta.class("meta.Tiling", "meta.Sprite", {
    create: function(params) {
        this.$shader = meta.resources.get("shader", "tiling");
        this._super(params);
    },
    cleanup: function() {
        this._super();
        if (this.$autoResize) {
            meta.off("resize", this.updateAutoResize, this);
        }
    },
    render: function(gl, buffer) {
        if (!this.texture) {
            return;
        }
        if (!this.texture.loaded) {
            return;
        }
        buffer[0] = this.volume.minX;
        buffer[1] = this.volume.minY;
        buffer[2] = this.volume.maxX;
        buffer[3] = this.volume.minY;
        buffer[4] = this.volume.maxX;
        buffer[5] = this.volume.maxY;
        buffer[6] = this.volume.minX;
        buffer[7] = this.volume.maxY;
        gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.DYNAMIC_DRAW);
        gl.bindTexture(gl.TEXTURE_2D, this.texture.instance);
        var width = this.texture.width;
        var height = this.texture.height;
        var numTilesX = this.volume.width / width;
        gl.uniform1f(this.$shader.uniform.tilesX, numTilesX);
        var numTilesY = this.volume.height / height;
        gl.uniform1f(this.$shader.uniform.tilesY, numTilesY);
        var offsetX = meta.camera.x % width;
        if (offsetX !== 0) {
            offsetX = 1 / width * offsetX;
        }
        var offsetY = meta.camera.y % height;
        if (offsetY !== 0) {
            offsetY = 1 / height * offsetY;
        }
        gl.uniform1f(this.$shader.uniform.offsetX, offsetX);
        gl.uniform1f(this.$shader.uniform.offsetY, offsetY);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    },
    updateFromTexture: function() {
        this._super();
        if (this.$autoResize) {
            this.updateAutoResize(meta.engine);
        }
    },
    set autoResize(value) {
        if (this.$autoResize === value) {
            return;
        }
        this.$autoResize = value;
        if (value) {
            meta.on("resize", this.updateAutoResize, this);
            this.updateAutoResize(meta.engine);
        } else {
            meta.off("resize", this.updateAutoResize, this);
        }
    },
    get autoResize() {
        return this.$autoResize;
    },
    updateAutoResize: function(engine) {
        this.resize(engine.width, engine.height);
    },
    $autoResize: false
});

"use strict";

meta.class("meta.Text", "meta.Sprite", {});

"use strict";

meta.class("meta.Particle", {});

"use strict";

meta.on("domload", function() {
    meta.engine.init();
});

function DomLoad() {
    if (document.readyState === "interactive" || document.readyState === "complete") {
        meta.emit("domload");
        return;
    }
    var cbFunc = function(event) {
        meta.emit("domload");
        window.removeEventListener("DOMContentLoaded", cbFunc);
    };
    window.addEventListener("DOMContentLoaded", cbFunc);
}

DomLoad();
"use strict";

meta.on("load", function() 
{
	meta.camera.draggable = true;
	meta.renderer.bgColor = "0x333333";
});

meta.loader = 
{
	register: function(editor)
	{
		meta.resources.rootPath = editor.projectPath + "/";

		this.registerFuncs();

		var data = editor.dataPublic;
		var assets = data.get("assets");
		var assetsRaw = assets.raw;
		for(var key in assetsRaw) {
			this.registerItems(key, assets.get(key));
		}

		this.loadGrid();

		this.load(data.get("hierarchy"));
	},

	registerFuncs: function()
	{
		this.typeClasses = {
			texture: meta.Texture,
			sprite: meta.Sprite,
			view: meta.View,
		};
	},

	registerItems: function(type, data)
	{
		var cls = this.typeClasses[type];
		if(!cls) {
			console.warn("(meta.loader.registerItems) Type is unsupported: " + type);
			return;
		}

		data.watch(this.watchAssetType, this);

		var raw = data.raw;
		for(var key in raw)
		{
			var itemData = data.get(key);

			this.registerItem(itemData, cls);
		}
	},

	registerItem: function(data, cls)
	{
		var item = meta.new(cls, null, data.id);
		item.data = data;		
	},

	watchAssetType: function(action, key, value, index, data)
	{
		switch(action)
		{
			case "add":
			{
				var cls = this.typeClasses[value.raw.type];
				if(!cls) {
					console.warn("(meta.loader.watchAssetType) Type is unsupported: " + type);
					break;
				}

				this.registerItem(value, cls);
			} break;

			case "remove":
				meta.resources.remove(value.raw.type, value.id);
				break;
		}
	},

	load: function(data)
	{
		data.watch(this.watchHierarchyData, this);

		var raw = data.raw;
		for(var key in raw) 
		{
			var itemData = data.get(key);
			this.loadItem(itemData);
		}
	},

	loadItem: function(data)
	{
		var type = data.raw.type;

		var cls = this.typeClasses[type];
		if(!cls) {
			console.warn("(meta.loader.loadItem) Type is unsupported: " + type);
			return;
		}

		var item = meta.new(cls);
		item.data = data;
		
		switch(type)
		{
			case "sprite":
				meta.layer.add(item);
				break;

			case "view":
				break;
		}		
	},

	watchHierarchyData: function(action, key, value, index, data)
	{
		switch(action)
		{
			case "add":
				this.loadItem(value);
				break;

			case "remove":
			{
				var type = value.get("type");
				switch(type)
				{
					case "sprite":
						meta.layer.remove(value.id);
						break;
				}
			} break;
		}
	},

	loadGrid: function()
	{
		var gridCanvas = document.createElement("canvas");
		gridCanvas.width = 128;
		gridCanvas.height = 96;

		var gridCtx = gridCanvas.getContext("2d");

		gridCtx.beginPath();
		gridCtx.lineWidth = 2;
		gridCtx.strokeStyle = "#222";
		gridCtx.moveTo(0, -0);
		gridCtx.lineTo(0, 128);
		gridCtx.moveTo(0, 0);
		gridCtx.lineTo(128, 0);	
		gridCtx.stroke();

		var texture = meta.new(meta.Texture, gridCanvas);
		texture.anisotropy = false;

		var entity = meta.new(meta.Tiling, texture);
		entity.autoResize = true;
		entity.z = 10000;

		var gridLayer = meta.createLayer("grid");
		gridLayer.fixed = true;
		gridLayer.z = 10000000000;
		gridLayer.add(entity);
	},

	//
	typeClasses: null
};

"use strict";

editor.plugin("meta2d",
{
	onPrepare: function()
	{
		this.loadTypes();
		this.loadContextMenu();
		this.loadInspect();
	},

	onStart: function()
	{
		var layout = editor.plugins.layout;
		this.rulerHorizontal = layout.template.get("#ruler-horizontal");
		this.rulerVertical = layout.template.get("#ruler-vertical");

		this.iframe = wabi.createElement("iframe");
		this.iframe.$value = "plugins/meta2d/meta2d/index/index.html";
		this.iframe.on("load", this.handleIframeLoad, this);
		this.iframe.appendTo(layout.toolbarIFrame);
	},

	handleIframeLoad: function() 
	{
		var wnd = this.iframe.wnd;
		wnd.meta.loader.register(editor);
		wnd.meta.on("camera-move", this.handleCameraMove.bind(this));
		wnd.addEventListener("mousemove", this.handleMouseMove.bind(this));
		wnd.addEventListener("resize", this.handleResize.bind(this));
		this.handleResize(null);
	},

	handleCameraMove: function(camera)
	{
		this.rulerHorizontal.updatePos(camera.x);
		this.rulerVertical.updatePos(camera.y);
	},

	handleMouseMove: function(event)
	{
		this.rulerHorizontal.updateCursor(event.x);
		this.rulerVertical.updateCursor(event.y);
	},

	handleResize: function(event) 
	{
		this.rulerHorizontal.updateSize();
		this.rulerVertical.updateSize();
	},

	loadTypes: function()
	{
		var resources = editor.plugins.resources;

		resources.addType("sprite", {
			icon: "fa-rocket"
		});

		resources.addType("layer", {
			icon: "fa-photo"
		});
	},

	loadContextMenu: function()
	{
		var contextmenu = editor.plugins.contextmenu;

		contextmenu.add("hierarchy", {
			Create: {
				content: {
					Sprite: {
						icon: editor.plugins.resources.getIconFromType("sprite"),
						func: this.createSprite.bind(this)
					},
					Layer: {
						icon: editor.plugins.resources.getIconFromType("layer"),
						func: this.createLayer.bind(this)
					},
					Folder: {
						icon: editor.plugins.resources.getIconFromType("folder"),
						func: this.createFolder.bind(this)
					}
				}
			}
		});

		contextmenu.add("hierarchyItem", "hierarchy", {
			Actions: {
				content: {
					Delete: {
						icon: "fa-trash",
						func: this.deleteItem.bind(this)
					}
				}
			}
		});
	},

	createFolder: function(event)
	{
		editor.dataPublic.get("hierarchy").add("@", {
			value: "Folder",
			type: "folder"
		});
	},

	createSprite: function(event)
	{
		editor.dataPublic.get("hierarchy").add("@", {
			value: "Sprite",
			type: "sprite"
		});
	},

	createLayer: function(event)
	{
		editor.dataPublic.get("hierarchy").add("@", {
			value: "Layer",
			type: "layer"
		});
	},	

	deleteItem: function(event)
	{
		var item = editor.plugins.browser.cache.selected;
		if(!item) { return; }

		editor.dataPublic.get("hierarchy").remove(item.data.id);
	},

	//
	iframe: null,
	rulerHorizontal: null,
	rulerVertical: null,
});

"use strict";

"require meta2d";

editor.plugin.meta2d.prototype.loadInspect = function()
{
	var inspect = editor.plugins.inspect;

	wabi.addFragment("inspect-folder", "inspect-general")

	wabi.addFragment("inspect-sprite", "inspect-general", [
		{
			type: "section",
			$name: "Transform",
			$value: [		
				{
					type: "label",
					$name: "Position",
					$value: [
						{
							type: "taggedNumber",
							bind: "x",
							$name: "x",
							$color: "#D04031"
						},
						{
							type: "taggedNumber",
							bind: "y",
							$name: "y",
							$color: "#72B529"
						}					
					]
				},
				{
					type: "labelNumber",
					bind: "angle",
					$name: "Angle"
				},
				{
					type: "label",
					$name: "Scale",
					$value: [
						{
							type: "taggedNumber",
							bind: "scaleX",
							$name: "x",
							$value: 1.0,
							$color: "#D04031"
						},
						{
							type: "taggedNumber",
							bind: "scaleY",
							$name: "y",
							$value: 1.0,
							$color: "#72B529"
						}
					]
				},
				{
					type: "label",
					$name: "Anchor",
					$value: [
						{
							type: "taggedNumber",
							bind: "anchorX",
							$name: "x",
							$value: 1.0,
							$color: "#D04031"
						},
						{
							type: "taggedNumber",
							bind: "anchorY",
							$name: "y",
							$value: 1.0,
							$color: "#72B529"
						}
					]
				}			
			]
		},
		{
			type: "section",
			$name: "Rendering",
			$value: [
				{
					type: "labelNumber",
					bind: "z",
					$name: "Sorting Index"
				},
				{
					type: "labelCheckbox",
					bind: "hidden",
					$name: "Hidden"
				}					
			]
		},
		{
			type: "section",
			$name: "Texture",
			$value: [
				{
					type: "labelDropdown",
					bind: "texture",
					$name: "Texture",
					$dataset: "assets.texture",
					$emptyOption: true
				},
				{
					type: "label",
					$name: "Pivot",
					$value: [
						{
							type: "taggedNumber",
							bind: "pivotX",
							$name: "x",
							$value: 0.0,
							$color: "#D04031"
						},
						{
							type: "taggedNumber",
							bind: "pivotY",
							$name: "y",
							$value: 0.0,
							$color: "#72B529"
						}
					]
				}			
			]
		}
	]);

	wabi.addFragment("inspect-layer", "inspect-general", [
		{
			type: "section",
			$name: "Rendering",
			$value: [
				{
					type: "labelNumber",
					bind: "z",
					$name: "Sorting Index"
				},
				{
					type: "labelCheckbox",
					bind: "hidden",
					$name: "Hidden"
				}
			]
		},
	]);

	wabi.addFragment("inspect-texture", "inspect-general", [
		{
			type: "section",
			$name: "General",
			$value: [
				{
					type: "labelCheckbox",
					bind: "premultiplied",
					$name: "premultiplied",
					$value: true
				}
			]
		},
	]);
};

